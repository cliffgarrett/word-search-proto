<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Word-a-Roo ‚Äî Splash + Search (live preview, snake option, confetti)</title>
<style>
  :root{
    --bg:#0c1015; --fg:#e9eef4; --gold:#BD7B09; --blue:#0986D1;
    --panelW:clamp(320px, 92vw, 760px);
    --panelPad:14px;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
    font:600 16px/1.25 system-ui,-apple-system,Segoe UI,Inter,Roboto,Helvetica,Arial,sans-serif;}
  button{font:inherit}

  /* ---------- Splash ---------- */
  #splash{position:fixed;inset:0;display:grid;place-items:center;background:#000;}
  #splash.hidden{display:none}
  #splash img.bg{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;opacity:.9}
  .startWrap{position:relative;z-index:2;display:grid;gap:18px;place-items:center}
  .startBtn{appearance:none;border:none;border-radius:999px;padding:16px 28px;
    background:#0a7bd1;color:#fff;font-weight:900;letter-spacing:.02em;
    box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 -3px 0 rgba(0,0,0,.25); cursor:pointer}
  .startBtn:active{transform:translateY(1px)}

  

  /* ---------- HUD ---------- */
  header{position:fixed;left:0;right:0;top:0;display:flex;gap:.6rem;align-items:center;
    padding:.55rem .7rem;z-index:50;pointer-events:none}
  .chip{pointer-events:auto;background:rgba(20,20,22,.72);border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(8px); border-radius:14px; padding:.38rem .65rem;display:flex;gap:.45rem;
    align-items:center;font-weight:800}
  .hide{display:none!important}

  /* ---------- Word bar ---------- */
  #wordBar{position:fixed;left:50%;top:56px;transform:translateX(-50%);
    width:var(--panelW);padding:8px var(--panelPad);
    background:#fff;border-radius:18px;border:1px solid rgba(0,0,0,.1);color:#000;z-index:3}
  #wordList{display:flex;gap:18px;flex-wrap:wrap;justify-content:center}
  #wordList b{font-weight:900}
  #wordList .done{opacity:.35}

#wordBar {
    position: fixed;
    left: 50%;
    top: 56px;
    transform: translateX(-50%);
    width: calc(var(--panelW) - 30px);
    padding: 8px var(--panelPad);
    background: #fff;
    border-radius: 18px;
    border: 1px solid rgba(0,0,0,.1);
    color: #000;
    z-index: 3;
    top: 130px;
}
#wordList {
    display: grid;
    gap: 4px;
    flex-wrap: wrap;
    justify-content: center;
    grid-template-columns: 1fr 1fr 1fr;
    text-align: center;
    padding: 0px 6px;
}
  /* ---------- Board ---------- */
  #boardWrap{position:fixed;left:50%;top:120px;transform:translateX(-50%);
    width:var(--panelW);height:calc(100dvh - 120px - 18px);display:grid;place-items:center;z-index:1}
  #board{position:relative;width:100%;height:100%;display:grid;place-content:center}
  .card{position:relative;background:#fff;border-radius:24px;padding:18px;border:1px solid rgba(0,0,0,.12);
    width:100%;height:100%; overflow:hidden;} /* clip bands cleanly */

#boardWrap {
    position: fixed;
    left: 50%;
    top: 120px;
    transform: translateX(-50%);
    width: var(--panelW);
    height: calc(100dvh - 120px - 18px);
    display: grid;
    place-items: center;
    z-index: 1;
}
.card {
    position: relative;
    background: #fff;
    border-radius: 24px;
    padding: 0px;
    border: 1px solid rgba(0,0,0,.12);
    width: 100%;
    height: 100%;
    overflow: hidden;
    top: 10px;
}
  /* overlays (both ignore pointer hits) */
  #bands, #bandsPreview{position:absolute;inset:18px;pointer-events:none}
  /* Grid */
  #grid{position:relative;display:grid;gap:10px;user-select:none; touch-action:none;} /* critical on mobile */
  .cell{display:grid;place-items:center;background:transparent;color:#000;font-weight:900;
    font-size:clamp(20px, 5.6vw, 40px);
    width:min(12vw, 68px);height:min(12vw, 68px);border-radius:16px}
  .cell.sel{outline:3px solid #5fb5ff;outline-offset:2px;background:#f1f6ff}
  .cell.hint{position:relative}
  .cell.hint::after{content:"";position:absolute;inset:-4px;border-radius:18px;border:3px dashed #0a7bd1;animation:pulse 1s ease-in-out infinite}
  @keyframes pulse{0%{opacity:.2}50%{opacity:1}100%{opacity:.2}}

#grid {
    position: relative;
    display: grid;
    gap: 10px;
    user-select: none;
    touch-action: none;
    padding: 10px;
}
.cell {
    display: grid;
    place-items: center;
    background: transparent;
    color: #000;
    font-weight: 900;
    font-size: clamp(20px, 5.6vw, 40px);
    width: min(12vw, 68px);
    height: min(12vw, 68px);
    border-radius: 16px;
    /* padding: 6px; */
}

  /* pill (band) element */
  .band{position:absolute;border-radius:9999px;opacity:.92}
  .band.preview{opacity:.45; filter:saturate(1.2)}
  .band.pink{background:#F59CB0}
  .band.purple{background:#C8B6FF}
  .band.green{background:#A8F5A6}
  .band.gold{background:#FFD166}
  .band.blue{background:#9ADAFE}
  .band.orange{background:#FFB07C}

  /* ---------- Settings modal ---------- */
  #modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;place-items:center;z-index:60}
  #modal.show{display:grid}
  .panel{background:#16181d;color:#fff;border:1px solid rgba(255,255,255,.12);border-radius:18px; padding:16px; width:min(92vw,460px)}
  .row{display:flex;align-items:center;justify-content:space-between;padding:10px 6px}
  .row label{font-weight:700}
  .panel .close{margin-top:10px;width:100%}

  /* ---------- Toasts ---------- */
  #toasts{position:fixed;left:50%;bottom:28px;transform:translateX(-50%);display:grid;gap:10px;z-index:70;pointer-events:none}
  .toast{background:rgba(0,0,0,.75);color:#fff;border-radius:999px;padding:10px 16px;font-weight:900;animation:rise 1.1s ease forwards}
  @keyframes rise{from{opacity:0;transform:translate(-50%,10px)}to{opacity:1;transform:translate(-50%,-10px)}}

  /* ---------- Confetti (simple DOM pieces; swap to puzzle-piece PNGs later) ---------- */
  #confetti{position:fixed;inset:0;pointer-events:none;overflow:hidden;z-index:80}
  #confetti i{position:absolute;width:10px;height:10px;background:#fff;opacity:.9;
    animation:fall 1200ms linear forwards}
  @keyframes fall{to{transform:translateY(110vh) rotate(720deg);opacity:.2}}

  /* high contrast toggle */
  .hc .cell{color:#000}
  .hc #wordBar{background:#000;color:#fff;border-color:#333}

  /* --- Praise/messages above word list (auto-sized to panel width) --- */
#msgStack {
  position:fixed; z-index:65; pointer-events:none;
  display:grid; gap:8px;
}
.msg {
  justify-self:center;
  background:rgba(0,0,0,.78); color:#fff;
  border-radius:999px; padding:8px 14px; font-weight:900;
  transform:translateY(-6px); opacity:0; animation:msgRise 900ms ease forwards;
}
@keyframes msgRise { from {opacity:0; transform:translateY(6px)} to {opacity:1; transform:translateY(-6px)} }

.msg.good { background:#0a7bd1 }
.msg.bad  { background:#b00020 }

</style>
</head>
<body>

<!-- SPLASH -->
<section id="splash" aria-label="Splash">
  <img class="bg" id="splashImg" alt="Splash" src="https://raw.githubusercontent.com/cliffgarrett/word-search-proto/refs/heads/main/assets/img/splash.png">
  <div class="startWrap">
    <button id="btnStart" class="startBtn">‚ñ∂ Start</button>
  </div>
</section>

<!-- IN-GAME HUD -->
<header>
  <div id="btnCfg" class="chip">‚öôÔ∏è Settings</div>
  <div id="btnHint" class="chip">üí° Hint</div>
  <div class="chip">Level <span id="lvl">1</span></div>
</header>

<div id="msgStack" aria-live="polite"></div>

<!-- Words bar -->
<div id="wordBar" class="hide"><div id="wordList"></div></div>

<!-- Board -->
<main id="boardWrap" class="hide">
  <div id="board">
    <div class="card">
      <div id="bandsPreview"></div>
      <div id="bands"></div>
      <div id="grid" aria-label="letter grid"></div>
    </div>
  </div>
</main>

<!-- Settings modal -->
<div id="modal">
  <div class="panel">
    <h3 style="margin:0 0 8px 0">Settings</h3>
    <div class="row"><label>Snake Charmer (curving paths)</label><input type="checkbox" id="optSnake" checked></div>
    <div class="row"><label>Haptics</label><input type="checkbox" id="optHaptics" checked></div>
    <div class="row"><label>Tones on drag</label><input type="checkbox" id="optTones" checked></div>
    <div class="row"><label>Sensory-low (high contrast / low music)</label><input type="checkbox" id="optHC"></div>
    <button class="startBtn close">Close</button>
  </div>
</div>

<div id="toasts"></div>
<div id="confetti"></div>

<script>
/* ===== assets ===== */
const ASSETS = {
  img:   { splash:'assets/img/splash.png', search:'https://raw.githubusercontent.com/cliffgarrett/word-search-proto/refs/heads/main/img/search.png' },
  audio: { splash:'assets/audio/splash.mp3', search:'https://github.com/cliffgarrett/word-search-proto/raw/refs/heads/main/audio/search.mp3', trumpet:'https://github.com/cliffgarrett/word-search-proto/raw/refs/heads/main/audio/victory.mp3' }
};

/* ===== tiny audio helper ===== */
const Snd = (() => {
  const aSplash = new Audio(ASSETS.audio.splash);
  const aSearch = new Audio(ASSETS.audio.search);
  const aTrump  = new Audio(ASSETS.audio.trumpet);
  aSplash.preload='auto'; aSplash.loop=false; aSplash.volume=1;
  aSearch.preload='auto'; aSearch.loop=true; aSearch.volume=.55;
  aTrump.preload='auto';  aTrump.loop=false; aTrump.volume=.7;
  let unlocked=false, ctx=null;

  async function safePlay(a){ try{ a.currentTime=0; await a.play(); }catch{} }
  async function userInit(){
    if (unlocked) return;
    try{
      await safePlay(aSplash); aSplash.pause();
      await safePlay(aSearch); aSearch.pause();
      await safePlay(aTrump);  aTrump.pause();
      ctx = new (window.AudioContext||window.webkitAudioContext)();
      unlocked=true;
    }catch{}
  }
  function tone(freq=440, dur=0.06){
    if (!S.settings.tones || !ctx) return;
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.connect(g).connect(ctx.destination);
    o.type='sine'; o.frequency.value=freq;
    const t=ctx.currentTime;
    g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(0.2,t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.start(t); o.stop(t+dur+0.02);
  }
  function haptic(ms=8){ if (S.settings.haptics && navigator.vibrate) navigator.vibrate(ms); }

  async function playSplash(){ await safePlay(aSplash); }
  async function startSearch(){ await safePlay(aSearch); }
  function stopAll(){ [aSplash,aSearch,aTrump].forEach(a=>{ try{a.pause();}catch{} }); }
  async function trumpet(){ await safePlay(aTrump); }
  return { userInit, playSplash, startSearch, stopAll, trumpet, tone, haptic };
})();

/* ===== sample words (small/phone friendly) ===== */
const WORDS = ['BIRD','BUG','CLOUD','DRAGON','KITE','EMIT'];

/* Tiny temp dictionary: UPPERCASE words 3‚Äì8 letters.
   Replace with a real list later (or load per-level). */
const DICT = new Set([
  'BIRD','BUG','CLOUD','DRAGON','KITE','EMIT',
  'TIME','TIDE','CLOUDS','DRAG','DRAGONS',
  'TREE','STONE','RING','ROAD','EAST','WEST',
  'RAIN','WIND','FIRE','WATER','EARTH',
  'AIR','SUN','STAR','MOON'
]);

/* ===== state ===== */
const S = {
  level:1,
  rows:7, cols:6, grid:[], placed:[], foundIdx:new Set(), bonusWords:new Set(),
  dragging:false, selPath:[], previewNeedsRedraw:false,
  // settings
  settings:{ snake:false, haptics:true, tones:true, highContrast:false },
  bandColors:['pink','purple','green','gold','blue','orange']
};

/* ===== helpers ===== */
const $ = s => document.querySelector(s);
const gridEl = $('#grid'), bandsEl = $('#bands'), previewEl = $('#bandsPreview');
const wordBar = $('#wordBar'), wordList = $('#wordList');
const splash = $('#splash'), splashImg = $('#splashImg');
const boardWrap = $('#boardWrap'), lvlEl = $('#lvl');

function toast(msg){
  const t=document.createElement('div'); t.className='toast'; t.textContent=msg;
  $('#toasts').appendChild(t); setTimeout(()=>t.remove(),1100);
}

const msgStack = $('#msgStack');

function placeMsgStack() {
  const r = wordBar.getBoundingClientRect();
  msgStack.style.left   = (r.left + window.scrollX) + 'px';
  msgStack.style.top    = (r.top  + window.scrollY - 42) + 'px'; // ~just above bar
  msgStack.style.width  = r.width + 'px';
}
addEventListener('resize', placeMsgStack);
addEventListener('orientationchange', ()=> setTimeout(placeMsgStack, 80));

function praise(msg, type='good'){
  const n = document.createElement('div');
  n.className = 'msg ' + type;   // applies "msg good" or "msg bad"
  n.textContent = msg;
  msgStack.appendChild(n);
  setTimeout(()=> n.remove(), 1100);
}

function wordOf(path){ return path.map(id=>S.grid[id]).join(''); }

function isPlacedWord(word){
  return S.placed.some(p=> p.text===word || p.text===word.split('').reverse().join('') );
}
function isDictWord(word){
  return DICT.has(word);
}

/* ===== layout ===== */
function setupGridSize(){
  gridEl.style.gridTemplateColumns = `repeat(${S.cols}, 1fr)`;
}

/* ===== grid building ===== */
const R = (n) => Math.floor(Math.random()*n);
const idx = (r,c)=> r*S.cols+c;
const inb = (r,c)=> r>=0&&c>=0&&r<S.rows&&c<S.cols;
function buildEmpty(){ S.grid = Array(S.rows*S.cols).fill(''); }

function allowedDirs(){ return [[0,1],[1,0],[1,1],[1,-1],[-1,1],[-1,-1],[0,-1],[-1,0]]; }

function tryPlaceStraight(w){
  const W=w.split('');
  for(let t=0;t<420;t++){
    const dir = allowedDirs()[R(8)];
    const r0=R(S.rows), c0=R(S.cols);
    const r1=r0+dir[0]*(W.length-1), c1=c0+dir[1]*(W.length-1);
    if (!inb(r1,c1)) continue;
    let ok=true, path=[];
    for(let k=0;k<W.length;k++){
      const r=r0+dir[0]*k, c=c0+dir[1]*k, id=idx(r,c);
      const ch=S.grid[id]; if (ch && ch!==W[k]){ ok=false; break; }
      path.push(id);
    }
    if(!ok) continue;
    for(let k=0;k<W.length;k++) S.grid[path[k]] = W[k];
    S.placed.push({text:w, path});
    return true;
  }
  return false;
}
function fillRandom(){
  const BAG="EEEEEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNRRRRRSSSSTTTTTDLLLLUGGBBCCMMPPFFHHVVWWYKJXQZ";
  for(let i=0;i<S.grid.length;i++) if(!S.grid[i]) S.grid[i]=BAG[R(BAG.length)];
}

/* ===== rendering ===== */
function renderGrid(){
  gridEl.innerHTML='';
  for(let i=0;i<S.grid.length;i++){
    const d=document.createElement('div'); d.className='cell'; d.textContent=S.grid[i]; d.dataset.idx=i;
    gridEl.appendChild(d);
  }
  setupGridSize();
}
function renderWords(){
  wordList.innerHTML='';
  WORDS.forEach((w,i)=>{
    const el=document.createElement('span');
    el.innerHTML = `<b>${w}</b>`; el.id='word_'+i;
    wordList.appendChild(el);
  });
}
function markWordDone(i){ $('#word_'+i)?.classList.add('done'); }

/* ===== selection helpers ===== */
function rcOf(id){ return [(id/S.cols)|0, id%S.cols]; }
function neighbors(id){
  const [r,c]=rcOf(id); const out=[];
  for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]]){
    const rr=r+dr, cc=c+dc; if(inb(rr,cc)) out.push(idx(rr,cc));
  }
  return out;
}
function segmentStraight(path){
  if (path.length<2) return [];
  const segs=[]; let a=path[0], b=path[1];
  let dr = Math.sign(rcOf(b)[0]-rcOf(a)[0]), dc = Math.sign(rcOf(b)[1]-rcOf(a)[1]);
  let cur=[a,b];
  for(let i=2;i<path.length;i++){
    const p=path[i], [rPrev,cPrev]=rcOf(path[i-1]); const [r,c]=rcOf(p);
    const dr2=Math.sign(r-rPrev), dc2=Math.sign(c-cPrev);
    if (dr2===dr && dc2===dc){ cur.push(p); }
    else{ segs.push(cur.slice()); cur=[path[i-1], p]; dr=dr2; dc=dc2; }
  }
  segs.push(cur.slice());
  return segs;
}

/* ----- pill drawing ----- */
function cellRect(id){
  const cell = gridEl.children[id];
  const hostRect = previewEl.getBoundingClientRect(); // same inset as bands
  const r = cell.getBoundingClientRect();
  return {
    cx: r.left - hostRect.left + r.width/2,
    cy: r.top  - hostRect.top  + r.height/2,
    w: r.width, h: r.height
  };
}
function clearBands(){ bandsEl.innerHTML=''; }
function clearPreview(){ previewEl.innerHTML=''; }
function drawBandSegment(container, aId,bId,colorClass, preview=false){
  const A=cellRect(aId), B=cellRect(bId);
  const dx=B.cx-A.cx, dy=B.cy-A.cy;
  const len=Math.hypot(dx,dy) + Math.min(A.w,A.h)*0.68; // extra for round caps
  const angle=Math.atan2(dy,dx)*180/Math.PI;
  const thickness = Math.min(A.h, A.w)*0.72;
  const div=document.createElement('div');
  div.className='band '+colorClass+(preview?' preview':'');
  div.style.width = `${len}px`;
  div.style.height = `${thickness}px`;
  div.style.left = `${(A.cx+B.cx)/2 - len/2}px`;
  div.style.top  = `${(A.cy+B.cy)/2 - thickness/2}px`;
  div.style.transform = `rotate(${angle}deg)`;
  container.appendChild(div);
}
function drawPillForPath(path, colorClass, preview=false){
  const segs = segmentStraight(path);
  for(const seg of segs){
    // draw ONE capsule for the entire straight run
    drawBandSegment(preview?previewEl:bandsEl, seg[0], seg[seg.length-1], colorClass, preview);
  }
}

/* ----- selection rendering while dragging ----- */
function updateCellSelection(){
  [...gridEl.children].forEach(c=>c.classList.remove('sel'));
  for(const id of S.selPath){ gridEl.children[id].classList.add('sel'); }
}
function redrawPreview(){
  clearPreview();
  if (S.selPath.length>1){
    const color = 'blue'; // neutral preview color
    drawPillForPath(S.selPath, color, true);
  }
}

/* match + claim */
function tryMatchCurrent(sel){
  for(let i=0;i<S.placed.length;i++){
    if (S.foundIdx.has(i)) continue;
    const p=S.placed[i].path;
    if (p.length!==sel.length) continue;
    const fwd = p.every((v,k)=>v===sel[k]);
    const rev = p.every((v,k)=>v===sel[p.length-1-k]);
    if (fwd||rev) return i;
  }
  return -1;
}
function checkWin(){
  if (S.foundIdx.size === S.placed.length) {
    Snd.stopAll();
    confetti();
    praise('Level complete!');
    let advanced = false;

    // attempt to use audio 'ended'
    const a = new Audio(ASSETS.audio.trumpet);
    a.volume = .8;
    a.onended = ()=>{ if(!advanced){ advanced=true; nextLevel(); } };
    a.onerror = ()=>{ if(!advanced){ advanced=true; setTimeout(nextLevel, 1400); } };
    a.play().catch(()=>{ if(!advanced){ advanced=true; setTimeout(nextLevel, 1400); } });

    // hard fallback in case browser blocks onended
    setTimeout(()=>{ if(!advanced){ advanced=true; nextLevel(); } }, 4000);
  }
}
function claim(i){
  S.foundIdx.add(i);
  markWordDone(i);
  const color = S.bandColors[i % S.bandColors.length];
  drawPillForPath(S.placed[i].path, color);
  toast('Nice!');
  checkWin();
}

/* ----- bonus finds (any 3+ straight path not on list) ----- */
function lettersOf(path){ return path.map(id=>S.grid[id]).join(''); }
function tryBonus(sel){
  if (sel.length<3) return false;
  const word = lettersOf(sel);
  const isPlaced = S.placed.some(p=>p.text===word || p.text===word.split('').reverse().join(''));
  if (isPlaced) return false;
  if (S.bonusWords.has(word)) return false;
  S.bonusWords.add(word);
  drawPillForPath(sel, 'gold'); // show it!
  toast(['Great find!','Outstanding!','Brilliant!'][R(3)] + (word?` ${word}`:''));
  return true;
}

/* ----- pointer input (with capture) ----- */
let activePointer=null;
gridEl.addEventListener('pointerdown', e=>{
  const el=e.target.closest('.cell'); if(!el) return;
  gridEl.setPointerCapture(e.pointerId);
  activePointer=e.pointerId;
  S.dragging=true; S.selPath=[+el.dataset.idx];
  updateCellSelection(); redrawPreview();
  e.preventDefault();
},{passive:false});

gridEl.addEventListener('pointermove', e=>{
  if(!S.dragging || e.pointerId!==activePointer) return;
  const el=document.elementFromPoint(e.clientX,e.clientY)?.closest('.cell'); if(!el) return;
  const id=+el.dataset.idx;
  const last=S.selPath[S.selPath.length-1];
  if (id===last) return;

  // backtrack
  const prev=S.selPath[S.selPath.length-2];
  if (prev!=null && id===prev){ S.selPath.pop(); updateCellSelection(); redrawPreview(); return; }

  // must be adjacent and not already in path (unless snake off, then straight-only)
  if (!neighbors(last).includes(id)) return;

  if (!S.settings.snake){
    // restrict to straight-only growth
    if (S.selPath.length>=2){
      const [r0,c0]=rcOf(S.selPath[0]), [r1,c1]=rcOf(S.selPath[1]), [r,c]=rcOf(id);
      const dr = Math.sign(r1-r0), dc = Math.sign(c1-c0);
      const [rp,cp]=rcOf(last);
      if (Math.sign(r-rp)!==dr || Math.sign(c-cp)!==dc) return; // block bends
    }
  }
  if (S.selPath.includes(id)) return; // no loops for now

  S.selPath.push(id);
  if (S.selPath.length > 12) { return; } // soft cap; tweak later
  updateCellSelection(); redrawPreview();
  Snd.haptic(8);
  Snd.tone(300 + S.selPath.length*60, 0.05);
},{passive:false});

function endSelection(){
  if(!S.dragging) return;
  S.dragging=false; activePointer=null;

  const w = wordOf(S.selPath);
  const matchIdx = tryMatchCurrent(S.selPath);

  if (matchIdx >= 0){
    claim(matchIdx);
    praise('Nice!');
  } else {
    // Allow bonus only if it's a real word from DICT (3+ letters)
    if (S.selPath.length >= 3 && isDictWord(w) && !isPlacedWord(w)) {
      S.bonusWords.add(w);
      drawPillForPath(S.selPath, 'gold');
      praise(['Great find!','Outstanding!','Brilliant!'][R(3)] + ` ${w}`);
    } else {
      // Not a word -> clear selection immediately
      praise('Not a word!', 'bad');
      // praise('Try again!', 'bad');
    }
  }

  S.selPath.length=0;
  updateCellSelection(); clearPreview();
}
addEventListener('pointerup', endSelection, {passive:true});
addEventListener('pointercancel', ()=>{ S.dragging=false; activePointer=null; S.selPath.length=0; updateCellSelection(); clearPreview(); }, {passive:true});
addEventListener('pointerleave',  ()=>{ /* keep selection if pointer captured */ }, {passive:true});

/* ----- resize -> redraw bands ----- */
function redrawAllBands(){
  clearPreview();
  const found=[...S.foundIdx];
  clearBands();
  for(const i of found){
    const color = S.bandColors[i % S.bandColors.length];
    drawPillForPath(S.placed[i].path, color);
  }
}
addEventListener('resize', ()=>{ redrawAllBands(); });
addEventListener('orientationchange', ()=>{ setTimeout(redrawAllBands, 120); });

/* ===== hint (first letter of a remaining word) ===== */
function hint(){
  const i = S.placed.findIndex((p,ix)=>!S.foundIdx.has(ix));
  if (i<0) return;
  const firstId = S.placed[i].path[0];
  [...gridEl.children].forEach(c=>c.classList.remove('hint'));
  gridEl.children[firstId].classList.add('hint');
}

/* ===== win confetti (square pieces now; can swap to puzzle-piece PNGs later) ===== */
function confetti(){
  const host = $('#confetti');
  host.innerHTML='';
  const colors = ['#FF6B6B','#FFD166','#4ECDC4','#C7F464','#C8B6FF','#9ADAFE','#FFB07C'];
  const n = 90;
  for(let i=0;i<n;i++){
    const d=document.createElement('i');
    d.style.left = (Math.random()*100)+'vw';
    d.style.top  = (-10 - Math.random()*30)+'vh';
    d.style.background = colors[R(colors.length)];
    d.style.width = d.style.height = (6+Math.random()*8)+'px';
    d.style.animationDuration = (800+Math.random()*700)+'ms';
    host.appendChild(d);
  }
  setTimeout(()=>host.innerHTML='',1600);
}

/* ===== level control ===== */
function nextLevel(){
  S.level++; lvlEl.textContent=S.level;
  startGame(true);
}

/* ===== UI wire ===== */
$('#btnCfg').onclick = ()=> $('#modal').classList.add('show');
$('.close').onclick  = ()=> $('#modal').classList.remove('show');
$('#optSnake').onchange   = e=> S.settings.snake = e.target.checked;
$('#optHaptics').onchange = e=> S.settings.haptics = e.target.checked;
$('#optTones').onchange   = e=> S.settings.tones = e.target.checked;
$('#optHC').onchange      = e=>{
  S.settings.highContrast = e.target.checked;
  document.body.classList.toggle('hc', S.settings.highContrast);
  // lower music in sensory-low
  // (actual loop volume already moderate; could duck further here if desired)
};
$('#btnHint').onclick = hint;

/* ===== splash ===== */
splashImg.src = ASSETS.img.splash;
$('#btnStart').onclick = async () => {
  await Snd.userInit();
  Snd.stopAll();
  Snd.playSplash();
  startGame();
};

/* ===== game start ===== */
function startGame(isNext=false){
  // UI
  splash.classList.add('hidden');
  wordBar.classList.remove('hide');
  boardWrap.classList.remove('hide');

  // BG for search
  document.body.style.backgroundImage = `url(${ASSETS.img.search})`;
  document.body.style.backgroundSize = 'cover';
  document.body.style.backgroundPosition='center';

  // build
  S.rows=7; S.cols=6;
  S.grid.length=0; S.placed.length=0; S.foundIdx.clear?.(); S.bonusWords.clear?.();
  buildEmpty();
  for(const w of WORDS) tryPlaceStraight(w);
  fillRandom();
  renderWords();
  placeMsgStack();
  renderGrid();
  clearBands(); clearPreview();
  [...gridEl.children].forEach(c=>c.classList.remove('hint'));

  // start calm loop
  Snd.stopAll();
  Snd.startSearch();
}

/* ===== boot ===== */
</script>
</body>
</html>
