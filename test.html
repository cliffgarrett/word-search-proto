<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Word Search + Unscramble</title>
<style>
  :root{ --fg:#e9eef4; --bg:#0f1011; --chip:rgba(20,20,22,.72); --sab:env(safe-area-inset-bottom,0px);
         --ok:#87f59f; --bad:#ff6b6b; --accent:#7aa7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;}
html, body {
  margin: 0;
  height: 100%;
  /* Nebula gradient background */
  background: radial-gradient(
      circle at 20% 30%, 
      rgba(255, 0, 128, 0.6), 
      transparent 60%
    ),
    radial-gradient(
      circle at 80% 40%, 
      rgba(138, 43, 226, 0.6), 
      transparent 70%
    ),
    radial-gradient(
      circle at 50% 80%, 
      rgba(75, 0, 130, 0.6), 
      transparent 60%
    ),
    linear-gradient(
      135deg, 
      #0f0f1a 0%, 
      #1a0f2b 100%
    );
  background-blend-mode: screen, lighten, overlay, normal;
  background-attachment: fixed;
  background-size: cover;
  color: #fff;
}
html, body {
  margin: 0;
  height: 100%;
  background: linear-gradient(270deg, #0f0c29, #302b63, #7a00cc, #ff0077);
  background-size: 800% 800%;
  animation: driftGradient 28s ease infinite;
  color: var(--fg);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
}

html, body {
  /* background: linear-gradient(-45deg, #2a003f, #4b0082, #7b2cbf, #6a0dad); */
  /* background: linear-gradient(-45deg in oklch, red, orange, yellow, green, blue, indigo, violet); */
  background: linear-gradient(-45deg in oklch, red, orange, green, blue, indigo, violet);
  
  background-size: 600% 600%;
  animation: driftGradient 120s ease infinite;
}

@keyframes driftGradient {
  0% { background-position: 0% 0%; }
  50% { background-position: 100% 100%; }
  100% { background-position: 0% 0%; }
}
  
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column;}
  header{position:fixed;left:0;right:0;top:0;display:flex;gap:.5rem .6rem;flex-wrap:wrap;
    align-items:center;padding:.55rem .7rem;z-index:30;pointer-events:none}
  .chip{pointer-events:auto;background:var(--chip);border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(8px); border-radius:14px; padding:.35rem .6rem;
    display:flex; gap:.45rem; align-items:center; font-weight:700; white-space:nowrap}
  .btn{cursor:pointer; color: #FFFFFF}
  .pill{border-radius:999px; padding:.35rem .75rem}

  /* Top region (grid / unscramble swap) */
  #top{position:fixed; left:0; right:0; z-index:10}
  #gridWrap{display:flex; align-items:center; justify-content:center;}
  #grid{position:relative; display:grid; gap:.55rem; touch-action:none}
  .cell{width:auto;height:auto;background:#e8eef5;color:#0e1116;border-radius:25%;
    box-shadow: inset 0 -2px 0 rgba(0,0,0,.12);
    display:flex;align-items:center;justify-content:center;
    font-weight:800;font-size:1.small; letter-spacing:.02em; position:relative}
  .cell.sel{outline:3px solid #5fb5ff; outline-offset:2px; background:#f5f9ff}
  .cell.found{background:#d7ffe4}
  .cell.hint{ outline:3px dashed #49e68b; animation: hintPulse 1.1s ease-in-out 2; }
  @keyframes hintPulse{0%{outline-offset:0;opacity:.9}50%{outline-offset:4px;opacity:1}100%{outline-offset:0;opacity:.9}}

  /* Word list */
  #bottom{position:fixed; left:0; right:0; bottom:0; z-index:20;
    padding:.6rem .7rem calc(.6rem + var(--sab));
    background:linear-gradient(to top, rgba(10,10,12,.95), rgba(10,10,12,.7) 50%, transparent)}
  #words{display:grid; grid-template-columns:repeat(2, minmax(140px,1fr)); gap:.4rem .6rem}
  .w{background:#1c222b;border:1px solid rgba(255,255,255,.12); border-radius:.7rem;
     padding:.42rem .6rem; font-weight:800; letter-spacing:.06em; display:flex; gap:.4rem; align-items:center}
  .w.done{opacity:.45}
  .w.allfound .circ{opacity:1; border-color:#87f59f}
  .w.allfound span:not(.circ){opacity:.35}
  .circ{display:inline-flex;align-items:center;justify-content:center;
    width:1.35em;height:1.35em;border-radius:999px;border:2px solid var(--accent);font-weight:900}

  /* H2H: show one target word (local test mode) */
  .h2h #words{grid-template-columns:1fr}
  .h2h .w{display:none}
  .h2h .w.active{display:flex}

  /* Unscramble */
  #unsTop{display:none; height:100%; padding:.6rem .7rem;
    display:flex; flex-direction:column; align-items:center; justify-content:center}
  #unsSlots{display:flex; gap:.5rem; flex-wrap:wrap; margin:.6rem 0}
  .slot{ width:2.5rem; height:3.1rem; border-radius:.5rem;
    background:#141a21; border:2px solid rgba(255,255,255,.18);
    display:flex; align-items:center; justify-content:center; font-weight:900; font-size:1.35rem }
  #unsBank{display:flex; gap:.4rem; flex-wrap:wrap; }
  .chipL{background:#273141; border:1px solid rgba(255,255,255,.18);
    border-radius:.55rem; padding:.35rem .6rem; font-weight:900; cursor:pointer; color: #ffffff}
  #buzzRow{display:none; gap:.5rem; margin-top:.6rem; align-items:center; flex-wrap:wrap; justify-content:center}
  .buzz{background:#1e232a;border:1px solid rgba(255,255,255,.18); border-radius:.8rem;
    padding:.55rem .9rem; font-weight:900; cursor:pointer}
  .own{outline:2px solid var(--accent);}

/* Settings modal */
#cfg{
  position:fixed; inset:0; z-index:40; display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.45); backdrop-filter:blur(6px);
}
#cfg[hidden]{ display:none; }
#cfg .panel{
  width:min(92vw,480px); background:#14151a; color:var(--fg);
  border:1px solid rgba(255,255,255,.14); border-radius:14px; padding:14px;
  box-shadow:0 10px 30px rgba(0,0,0,.45);
}
#cfg h3{ margin:.1rem 0 .7rem 0; }
#cfg .row{ display:flex; align-items:center; justify-content:space-between; margin:.4rem 0; gap:.8rem; }
#cfg select{
  background:#1c2027; color:var(--fg); border:1px solid rgba(255,255,255,.18);
  border-radius:10px; padding:.35rem .55rem; min-width:170px; font-weight:600;
}
#cfg .actions{ display:flex; justify-content:flex-end; gap:.5rem; margin-top:.7rem; }

/* theme hooks ‚Äì you already have the drifting gradient; these just tweak hues */
body[data-theme="plum"]   :root{ --drift-h1: 285; --drift-h2: 330; } /* default */
body[data-theme="indigo"] :root{ --drift-h1: 255; --drift-h2: 300; }
body[data-theme="magenta"]:root{ --drift-h1: 315; --drift-h2: 345; }
  .hide, .d-none{ display:none !important; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div id="btnStart" class="chip btn">‚ñ∂ Start</div>
    <div id="modeChip" class="chip btn d-none" style="display: none;">Mode: <b id="hudMode">Solo</b></div>
    <div class="chip">Stage: <b id="hudStage" style="display: none;">Search</b></div>
    <div id="btnCfg" class="chip btn">‚öôÔ∏è Settings</div>
    <div id="timeChip" class="chip">‚è± <b id="hudTime">‚Äî</b> s</div>
    <div id="hintBtn" class="chip btn" style="display:none">üí° Hint</div>
    <div id="diffChip" class="chip btn d-none" style="display: none;">Difficulty: <b id="hudDiff">Easy</b></div>
    <div class="chip pill">P1 ‚≠ê <b id="p1Score">0</b></div>
    <div id="p2Chip" class="chip pill">P2 ‚≠ê <b id="p2Score">0</b></div>
  </header>
  <div id="top">
    <div id="gridWrap"><div id="grid" aria-label="letter grid"></div></div>
    <div id="unsTop">
      <div id="unsSlots"></div>
      <div id="unsBank"></div>
      <div id="buzzRow">
        <button id="buzzP1" class="buzz">P1 Buzz</button>
        <button id="buzzP2" class="buzz">P2 Buzz</button>
        <div id="ownerMsg" style="opacity:.85"></div>
      </div>
      <div style="margin-top:.6rem;display:flex;gap:.5rem;flex-wrap:wrap">
        <button id="unsClear" class="chip btn">Clear</button>
        <button id="unsSubmit" class="chip btn">Submit</button>
      </div>
      <div id="unsMsg" style="margin-top:.4rem;min-height:1.2rem"></div>
    </div>
    <div id="cfg" aria-modal="true" role="dialog" hidden>
  <div class="panel">
    <h3>Settings</h3>

    <label class="row">
      <span>Mode</span>
      <select id="cfgMode">
        <option value="solo">Solo</option>
        <option value="h2h">Head-to-Head (local test)</option>
      </select>
    </label>

    <label class="row">
      <span>Difficulty</span>
      <select id="cfgDiff">
        <option>Easy</option>
        <option>Normal</option>
        <option>Hard</option>
        <option>Expert</option>
        <option>Zen</option>
      </select>
    </label>

    <label class="row">
      <span>Theme</span>
      <select id="cfgTheme">
        <option value="plum">Plum Drift (default)</option>
        <option value="indigo">Indigo</option>
        <option value="magenta">Magenta</option>
      </select>
    </label>

    <div class="actions">
      <button id="cfgCancel" class="chip btn">Cancel</button>
      <button id="cfgApply"  class="chip btn">Apply</button>
    </div>
  </div>
</div>
  </div>

  <div id="bottom">
    <div id="words"></div>
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
/* ========= helpers ========= */
const $ = s => document.querySelector(s);
const hudMode=$('#hudMode'), hudDiff=$('#hudDiff'), hudStage=$('#hudStage'), hudTime=$('#hudTime');
const p1ScoreEl=$('#p1Score'), p2ScoreEl=$('#p2Score'), gridEl=$('#grid'), wordsEl=$('#words');
const hintBtn=$('#hintBtn');
const buzz = pat => ('vibrate' in navigator) && navigator.vibrate(pat);

const timeChip = $('#timeChip');
const p2Chip   = $('#p2Chip'); 

function updateHudVisibility(){
  const solo = !S.h2h;

  // Hint: Solo only
  hintBtn.style.display = solo ? 'flex' : 'none';

  // P2 score: H2H only
  p2Chip?.classList.toggle('hide', solo);

  // Timer: Solo + UNSCRAMBLE only (and only if that stage actually uses a timer)
  const showTimer = solo && S.stage === 'unscramble' && !!CUR.unscrambleSecs;
  timeChip?.classList.toggle('hide', !showTimer);
}
/* ========= difficulty presets ========= */
const DIFFICULTY = {
  Easy:   { rows:10, cols:10, dirs:['H','V'],            backwards:false, words:6, searchSecs:null, hintAfter:8,  unscrambleSecs:20, dummies:0, mult:0.9, showHintBtn:true },
  Normal: { rows:12, cols:12, dirs:['H','V','D'],        backwards:'few', words:6, searchSecs:null, hintAfter:12, unscrambleSecs:25, dummies:0, mult:1.0, showHintBtn:false },
  Hard:   { rows:13, cols:13, dirs:['H','V','D'],        backwards:'more',words:7, searchSecs:null, hintAfter:16, unscrambleSecs:25, dummies:1, mult:1.2, showHintBtn:false },
  Expert: { rows:14, cols:14, dirs:['H','V','D'],        backwards:true,  words:8, searchSecs:null, hintAfter:null,unscrambleSecs:30, dummies:2, mult:1.4, showHintBtn:false },
  Zen:    { rows:12, cols:12, dirs:['H','V','D'],        backwards:false, words:6, searchSecs:null, hintAfter:6,  unscrambleSecs:60, dummies:0, mult:0.6, showHintBtn:true }
};
/* Timers: no Search timers at all; Unscramble timer only in Solo */
function timersForMode(diff, h2h){
  return { searchSecs:null, unscrambleSecs: h2h ? null : diff.unscrambleSecs };
}

/* ========= sample puzzle ========= */
const PUZZLE_BASE = {
  words: [
    {text:'APPLE', takeIndex:1},
    {text:'RADIO', takeIndex:3},
    {text:'SCALE', takeIndex:1},
    {text:'CANDY', takeIndex:2},
    {text:'SKIRT', takeIndex:2},
    {text:'ICING', takeIndex:1}
  ],
  finalAnswer: 'PICNIC'
};

/* ========= state ========= */
const S = {
  diffName:'Easy', diff: DIFFICULTY.Easy,
  h2h:false,
  grid:[], rows:10, cols:10,
  placed:[], found:new Set(),
  circled:[],
  stage:'search', time:0, running:false, last:0,
  idle:0, hintLock:false,
  p:[0,0], curP:0, wordIdx:0,
  dragging:false, startIdx:null, selPath:[],
  input:[], owner:null
};
function setMode(h2h){
  S.h2h = h2h;
  document.body.classList.toggle('h2h', h2h);
  hudMode.textContent = h2h ? 'H2H (local test)' : 'Solo';

  // üö´ Disable all hints in H2H
  if (h2h) {
    hintBtn.style.display = 'none';
    S.diff.hintAfter = null;  // no idle hints
  } else {
    hintBtn.style.display = (S.diff.showHintBtn ? 'flex' : 'none');
    S.diff.hintAfter = DIFFICULTY[S.diffName].hintAfter; // restore normal
  }
  updateHudVisibility();
}
function setDifficulty(name){
  S.diffName = name; S.diff = DIFFICULTY[name]; hudDiff.textContent = name;
  hintBtn.style.display = (S.diff.showHintBtn ? 'flex' : 'none');
}

/* ========= layout (mobile-friendly scaling) ========= */
function layout(){
  const headerEl = document.querySelector('header');
  const bottomEl = document.querySelector('#bottom');
  if (!headerEl || !bottomEl || !gridEl) return;

  const headH = headerEl.offsetHeight;
  const bottomH = bottomEl.offsetHeight;
  const topH = Math.max(220, innerHeight - headH - bottomH - 10);

  document.getElementById('top').style.top = headH + 'px';
  document.getElementById('top').style.height = topH + 'px';

  // ensure grid is actually grid + set columns
  gridEl.style.display = 'grid';
  gridEl.style.gridTemplateColumns = `repeat(${S.cols||10}, 1fr)`;

  const size = Math.min(innerWidth - 16, topH - 12);
  gridEl.style.width = size + 'px';
  gridEl.style.height = size + 'px';
}

addEventListener('resize', layout);
if (visualViewport) visualViewport.addEventListener('resize', layout);

/* ========= grid building ========= */
function allowedDirs(){
  const d = [];
  if (S.diff.dirs.includes('H')) d.push([0,1],[0,-1]);
  if (S.diff.dirs.includes('V')) d.push([1,0],[-1,0]);
  if (S.diff.dirs.includes('D')) d.push([1,1],[-1,-1],[1,-1],[-1,1]);
  return d;
}
const idx = (r,c)=> r*S.cols + c;
const inb = (r,c)=> r>=0 && c>=0 && r<S.rows && c<S.cols;
function buildEmpty(){ S.grid = Array(S.rows*S.cols).fill(''); }
function tryPlace(word){
  const W = word.text.toUpperCase();
  const dirs = allowedDirs();
  for (let attempt=0; attempt<220; attempt++){
    const dir = dirs[(Math.random()*dirs.length)|0];
    const len = W.length;
    const r0 = (Math.random()*S.rows)|0, c0 = (Math.random()*S.cols)|0;
    const r1 = r0 + dir[0]*(len-1), c1 = c0 + dir[1]*(len-1);
    if (!inb(r1,c1)) continue;
    let ok=true, path=[];
    for(let k=0;k<len;k++){
      const r=r0+dir[0]*k, c=c0+dir[1]*k, id=idx(r,c);
      const ch=S.grid[id]; if (ch && ch!==W[k]){ ok=false; break; }
      path.push(id);
    }
    if(!ok) continue;
    // backwards control
    const placeStr = (S.diff.backwards===true) ? (Math.random()<.5? W : [...W].reverse().join(''))
                    : (S.diff.backwards==='few' ? (Math.random()<.25? [...W].reverse().join('') : W)
                    : (S.diff.backwards==='more'? (Math.random()<.5? [...W].reverse().join('') : W) : W));
    for(let k=0;k<len;k++){ S.grid[path[k]] = placeStr[k]; }
    S.placed.push({text:W, path, takeIndex:word.takeIndex});
    return true;
  }
  return false;
}
function fillRandom(){
  const LETTERS="EEEEEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNRRRRRSSSSTTTTTDLLLLUGGBBCCMMPPFFHHVVWWYKJXQZ";
  for(let i=0;i<S.grid.length;i++) if(!S.grid[i]) S.grid[i]=LETTERS[(Math.random()*LETTERS.length)|0];
}

/* ========= render ========= */
function renderGrid(){
  gridEl.innerHTML = '';
  for (let i=0;i<S.grid.length;i++){
    const d = document.createElement('div');
    d.className = 'cell';
    d.textContent = S.grid[i];
    d.dataset.idx = i;
    gridEl.appendChild(d);
  }
  // make sure columns are applied whenever we rebuild
  gridEl.style.gridTemplateColumns = `repeat(${S.cols||10}, 1fr)`;
}
function renderWordList(){
  wordsEl.innerHTML='';
  // SEARCH PHASE: show plain words (no circles yet)
  PUZZLE_BASE.words.forEach((w,i)=>{
    const row=document.createElement('div'); row.className='w'; row.id='w_'+i;
    row.innerHTML = w.text.toUpperCase().split('').map(ch=>`<span>${ch}</span>`).join('');
    wordsEl.appendChild(row);
  });
  if (S.h2h){
    document.querySelectorAll('#words .w').forEach(w=>w.classList.remove('active'));
    $('#w_'+S.wordIdx)?.classList.add('active');
  }
}

/* ========= selection ========= */
function rcFromIdx(id){ return [(id/S.cols)|0, id%S.cols]; }
function dirOf(a,b){
  const [ar,ac]=rcFromIdx(a), [br,bc]=rcFromIdx(b);
  const dr=Math.sign(br-ar), dc=Math.sign(bc-ac);
  if(dr===0 && dc===0) return null;
  if(dr!==0 && dc!==0 && Math.abs(br-ar)!==Math.abs(bc-ac)) return null;
  return [dr,dc];
}
function cellsBetween(a,b){
  const d=dirOf(a,b); if(!d) return null;
  const [ar,ac]=rcFromIdx(a), [br,bc]=rcFromIdx(b);
  const n=Math.max(Math.abs(br-ar), Math.abs(bc-ac))+1, out=[];
  for(let k=0;k<n;k++){ const r=ar+d[0]*k, c=ac+d[1]*k; out.push(idx(r,c)); }
  return out;
}
function setSel(on,list){ for(const id of list){ gridEl.children[id]?.classList.toggle('sel',on); } }
function wordFrom(list){ return list.map(i=>S.grid[i]).join(''); }
function findPlacedByPath(list){
  const fwd=wordFrom(list), rev=wordFrom([...list].reverse());
  if (S.h2h){
    const target=PUZZLE_BASE.words[S.wordIdx].text.toUpperCase();
    if (fwd===target || rev===target) return S.placed.find(p=>p.text===target);
    return null;
  } else {
    return S.placed.find(p=>!S.found.has(p.text) && (p.text===fwd || p.text===rev));
  }
}

/* ========= hinting ========= */
function showHint(){
  if (S.stage!=='search') return;
  S.hintLock=true; setTimeout(()=>S.hintLock=false, 2600);
  let cand;
  if (S.h2h){
    cand = S.placed[S.wordIdx];
  } else {
    const pool=S.placed.filter(p=>!S.found.has(p.text));
    cand = pool[(Math.random()*pool.length)|0];
  }
  if (!cand) return;
  const id = cand.path[cand.takeIndex ?? ((Math.random()*cand.path.length)|0)];
  const cell = gridEl.children[id]; if (cell){ cell.classList.add('hint'); setTimeout(()=>cell.classList.remove('hint'),1400); }
}
hintBtn.onclick = showHint;

/* ========= run content ========= */
let CUR = { words:[], finalAnswer:'', unscrambleSecs:25 };
function makeRun(){
  CUR.words = PUZZLE_BASE.words.map(w=>({...w}));
  CUR.finalAnswer = PUZZLE_BASE.finalAnswer;
  const t = timersForMode(S.diff, S.h2h);
  CUR.unscrambleSecs = t.unscrambleSecs;
}

/* ========= game setup ========= */
function buildGame(){
  S.rows = S.diff.rows; S.cols = S.diff.cols;
  makeRun();

  S.grid.length=0; S.placed.length=0; S.found.clear(); S.circled.length=0;
  S.stage='search'; hudStage.textContent='Search';
  const t = timersForMode(S.diff,S.h2h);
  S.time = t.searchSecs || 0; S.running = false; hudTime.textContent='‚Äî';
  //updateHudVisibility():
  S.idle=0; S.hintLock=false;
  S.p=[0,0]; S.curP=0; S.wordIdx=0; updateScores();
  $('#gridWrap').style.display='flex'; $('#unsTop').style.display='none';
  $('#buzzRow').style.display = S.h2h ? 'flex' : 'none';
  setOwner(null);

  for(let tries=0; tries<60; tries++){
    buildEmpty(); S.placed.length=0;
    let ok=true; for(const w of CUR.words){ if (!tryPlace(w)){ ok=false; break; } }
    if (ok) break;
  }
  fillRandom(); renderGrid(); renderWordList(); layout();
}

/* ========= scoring ========= */
function scoreWord(len, player){
  const pts = Math.round(5 * len * (S.diff.mult||1));
  if (S.h2h) S.p[player]+=pts; else S.p[0]+=pts; updateScores();
}
function scoreBonus(bonus, player){
  const pts = Math.round(bonus * (S.diff.mult||1));
  if (S.h2h) S.p[player]+=pts; else S.p[0]+=pts; updateScores();
}
function updateScores(){ p1ScoreEl.textContent=S.p[0]; p2ScoreEl.textContent=S.p[1]; }

/* ========= selection & input ========= */
function markInteraction(){ S.idle = 0; }
['pointerdown','pointermove','keydown','click','touchstart'].forEach(ev => addEventListener(ev, markInteraction, {passive:true}));

gridEl.addEventListener('pointerdown', e=>{
  if (S.stage!=='search') return;
  const el=e.target.closest('.cell'); if(!el) return;
  S.dragging=true; S.selPath.length=0; S.startIdx=+el.dataset.idx;
  S.selPath=[S.startIdx]; setSel(true,S.selPath);
  gridEl.setPointerCapture(e.pointerId); e.preventDefault();
},{passive:false});
gridEl.addEventListener('pointermove', e=>{
  if(!S.dragging || S.stage!=='search') return;
  const el=document.elementFromPoint(e.clientX,e.clientY)?.closest('.cell'); if(!el) return;
  const id=+el.dataset.idx; if(id===S.startIdx) return;
  const seq=cellsBetween(S.startIdx,id); if(!seq) return;
  setSel(false,S.selPath); S.selPath=seq; setSel(true,S.selPath);
  e.preventDefault();
},{passive:false});
addEventListener('pointerup', e=>{
  if(!S.dragging) return; S.dragging=false;
  if(!S.selPath.length) return;
  const placed=findPlacedByPath(S.selPath);
  if(placed){
    if (S.h2h){
      awardWord(placed, S.curP);
      S.wordIdx++;
      if (S.wordIdx < CUR.words.length){
        $('#w_'+(S.wordIdx-1))?.classList.add('done');
        document.querySelectorAll('#words .w').forEach(w=>w.classList.remove('active'));
        $('#w_'+S.wordIdx)?.classList.add('active');
        S.curP = 1 - S.curP;
      } else {
        endSearchStartUnscramble();
      }
    } else {
      S.found.add(placed.text);
      for(const id of placed.path){ gridEl.children[id].classList.remove('sel'); gridEl.children[id].classList.add('found'); }
      const wIdx = S.placed.findIndex(p=>p.text===placed.text);
      $('#w_'+wIdx)?.classList.add('done');
      scoreWord(placed.text.length, 0);
      if (S.found.size === CUR.words.length) endSearchStartUnscramble();
    }
    buzz(12);
  } else {
    buzz([2,40,2]);
    setSel(false,S.selPath);
  }
  S.selPath.length=0;
});

/* ========= H2H awarding & owner ========= */
function awardWord(placed, player){
  for(const id of placed.path){ gridEl.children[id].classList.remove('sel'); gridEl.children[id].classList.add('found'); }
  const wIdx = S.placed.findIndex(p=>p.text===placed.text);
  $('#w_'+wIdx)?.classList.add('done');
  scoreWord(placed.text.length, player);
}
$('#buzzP1').onclick = ()=> setOwner(0);
$('#buzzP2').onclick = ()=> setOwner(1);
function setOwner(p){
  S.owner = p;
  $('#ownerMsg').textContent = (p==null) ? '' : `P${p+1} typing‚Ä¶`;
  $('#buzzP1').classList.toggle('own', p===0);
  $('#buzzP2').classList.toggle('own', p===1);
}

/* ========= stage transition ‚Üí Unscramble ========= */
function endSearchStartUnscramble(){
  // compute circled letters NOW and inject circles into the list for a reveal effect
  S.circled = PUZZLE_BASE.words.map(w => w.text[w.takeIndex]).filter(Boolean);
  document.querySelectorAll('#words .w').forEach((row, i)=>{
    const w = PUZZLE_BASE.words[i].text.toUpperCase();
    const k = PUZZLE_BASE.words[i].takeIndex|0;
    row.innerHTML = w.split('').map((ch, j)=> j===k ? `<span class="circ">${ch}</span>` : `<span>${ch}</span>`).join('');
    row.classList.add('allfound');
  });

  $('#gridWrap').style.display='none';
  $('#unsTop').style.display='flex';
  hudStage.textContent='Unscramble'; S.stage='unscramble';
updateHudVisibility();
  buildUnscramble();
  const t = timersForMode(S.diff,S.h2h).unscrambleSecs;
  S.time = t || 0; S.running = !!t; hudTime.textContent = S.running? Math.ceil(S.time) : '‚Äî';
  if (S.h2h) setOwner(S.curP);
}

/* ========= unscramble ========= */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
function buildUnscramble(){
  const slots = $('#unsSlots'), bank = $('#unsBank'), msg = $('#unsMsg');
  slots.innerHTML=''; bank.innerHTML=''; msg.textContent='';
  S.input.length=0;

  const letters = [...S.circled];
  const dummies = S.diff.dummies|0;
  const pool="ETAOINSHRDLUCMWFGYPBVKJXQZ";
  for(let i=0;i<dummies;i++) letters.push(pool[(Math.random()*pool.length)|0]);
  shuffle(letters);

  for (let i=0;i<PUZZLE_BASE.finalAnswer.length;i++){
    const s=document.createElement('div'); s.className='slot'; s.dataset.i=i; slots.appendChild(s);
  }
  letters.forEach((ch,i)=>{
    const b=document.createElement('button'); b.className='chipL'; b.textContent=ch; b.dataset.i=i;
    b.onclick=()=> pickFromBank(i);
    bank.appendChild(b);
  });
}
function pickFromBank(i){
  if (S.h2h && S.owner==null) return;
  const btn = $('#unsBank').querySelector(`.chipL[data-i="${i}"]`);
  if (!btn || btn.disabled) return;
  const k = S.input.length; if (k >= PUZZLE_BASE.finalAnswer.length) return;
  S.input.push(btn.textContent);
  $('#unsSlots').children[k].textContent = btn.textContent;
  btn.disabled = true; btn.style.opacity = .4;
  buzz(8);
}
$('#unsClear').onclick = ()=>{
  S.input.length=0;
  for(const s of $('#unsSlots').children) s.textContent='';
  for(const b of $('#unsBank').children){ b.disabled=false; b.style.opacity=1; }
};
$('#unsSubmit').onclick = ()=>{
  const guess = S.input.join('').toUpperCase();
  if (guess.length !== PUZZLE_BASE.finalAnswer.length){ setUnsMsg('Incomplete', false); buzz([2,40,2]); return; }
  if (guess === PUZZLE_BASE.finalAnswer.toUpperCase()){
    const bonus = Math.max(0, Math.ceil(S.time)) * 10;
    const winner = S.h2h ? (S.owner ?? S.curP) : 0;
    scoreBonus(bonus, winner);
    setUnsMsg(`Correct! +${bonus} ‚≠ê to P${winner+1}`, true);
    S.running=false; hudStage.textContent='Complete'; setOwner(null); buzz([10,40,10]);
  } else {
    setUnsMsg('Try again', false); buzz([2,40,2]);
    if (S.h2h) setOwner(null);
  }
};
function setUnsMsg(t, ok){ const el=$('#unsMsg'); el.textContent=t; el.style.color = ok? '#87f59f' : '#ff6b6b'; }

/* ========= timers / tick ========= */
function tick(now){
  if (!now) now=performance.now();
  const dt = S.last ? (now - S.last)/1000 : 0; S.last = now;

  if (S.stage==='search'){
    hudTime.textContent = '‚Äî';  // always no timer in Search
    // optional idle hint in Solo only
    if (!S.h2h && S.diff.hintAfter && !S.hintLock){
      S.idle += dt; if (S.idle >= S.diff.hintAfter){ showHint(); S.idle=0; }
    }
  } else if (S.stage==='unscramble'){
    if (!S.h2h && S.running){ S.time -= dt; if (S.time<=0){ S.time=0; S.running=false; setUnsMsg('Time!', false); } hudTime.textContent=Math.ceil(S.time); }
    else { hudTime.textContent='‚Äî'; }
  }

  requestAnimationFrame(tick);
}

/* ========= UI wiring ========= */
$('#btnStart').onclick = ()=>{ buildGame(); tick(); };
$('#modeChip').onclick = ()=>{ setMode(!S.h2h); buildGame(); };
$('#diffChip').onclick = ()=>{
  const order = Object.keys(DIFFICULTY);
  const i = order.indexOf(S.diffName);
  const next = order[(i+1)%order.length];
  setDifficulty(next); buildGame();
};

/* ========= boot ========= */
  setMode(false);
  setDifficulty('Easy');
  buildGame();
  layout();
  tick();

 // ==== Settings modal wiring ====
const cfg = $('#cfg'), cfgMode = $('#cfgMode'), cfgDiff = $('#cfgDiff'), cfgTheme = $('#cfgTheme');
$('#btnCfg').onclick = () => {
  // populate from current state
  cfgMode.value = S.h2h ? 'h2h' : 'solo';
  cfgDiff.value = S.diffName;
  cfgTheme.value = (localStorage.getItem('ws_theme') || 'plum');
  cfg.hidden = false;
};
$('#cfgCancel').onclick = () => { cfg.hidden = true; };

// apply & persist to
$('#cfgApply').onclick = () => {
  const wantH2H = (cfgMode.value === 'h2h');
  const wantDiff = cfgDiff.value;
  const theme = cfgTheme.value;

  // mode + difficulty (uses your existing helpers)
  setMode(wantH2H);
  setDifficulty(wantDiff);
  buildGame();

  // simple theme hook (class on body)
  document.body.dataset.theme = theme;
  localStorage.setItem('ws_theme', theme);

  cfg.hidden = true;
};

// optional: theme styles (minimal)
(function initTheme(){
  const t = localStorage.getItem('ws_theme') || 'plum';
  document.body.dataset.theme = t;
})(); 
});

</script>
</body>

</html>















