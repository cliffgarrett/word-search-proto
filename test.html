<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Word-a-Roo ‚Äî Rev R6-H2H-Supa-01</title>

<!-- Supabase client -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// ‚¨áÔ∏è fill these with your project details
const SB_URL = 'https://tootcjgayycxgazikjtx.supabase.co';
const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvb3RjamdheXljeGdhemlranR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg5NDQwMzIsImV4cCI6MjA3NDUyMDAzMn0.yTi_KNNoFuJtvDS1aH0NYZf3UMkTooBwjaZtzdM2ypY';
const sb = window.supabase.createClient(SB_URL, SB_KEY);
</script>

<style>
  :root{ --fg:#e9eef4; --bg:#0f1011; --chip:rgba(20,20,22,.72); --sab:env(safe-area-inset-bottom,0px);
         --ok:#87f59f; --bad:#ff6b6b; --accent:#7aa7ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;}
  /* drifting gradient background */
  html, body {
    background: linear-gradient(-45deg in oklch, red, orange, green, blue, indigo, violet);
    background-size: 600% 600%;
    animation: driftGradient 120s ease infinite;
  }
  @keyframes driftGradient { 0%{background-position:0% 0%} 50%{background-position:100% 100%} 100%{background-position:0% 0%} }

  #wrap{position:fixed;inset:0;display:flex;flex-direction:column;}
  header{position:fixed;left:0;right:0;top:0;display:flex;gap:.5rem .6rem;flex-wrap:wrap;
    align-items:center;padding:.55rem .7rem;z-index:30;pointer-events:none}
  .chip{pointer-events:auto;background:var(--chip);border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(8px); border-radius:14px; padding:.35rem .6rem;
    display:flex; gap:.45rem; align-items:center; font-weight:700; white-space:nowrap}
  .btn{cursor:pointer; color:#fff}
  .pill{border-radius:999px; padding:.35rem .75rem}

  /* Top region (grid / unscramble swap) */
  #top{position:fixed; left:0; right:0; z-index:10}
  #gridWrap{display:flex; align-items:center; justify-content:center;}
  #grid{position:relative; display:grid; gap:.55rem; touch-action:none}
  .cell{background:#e8eef5;color:#0e1116;border-radius:25%;
    box-shadow: inset 0 -2px 0 rgba(0,0,0,.12);
    display:flex;align-items:center;justify-content:center;
    font-weight:800;font-size:1.15rem; letter-spacing:.02em; position:relative}
  .cell.sel{outline:3px solid #5fb5ff; outline-offset:2px; background:#f5f9ff}
  .cell.found{background:#d7ffe4}
/* Enlarge touch/click target without changing visual spacing */
.cell { position: relative; }
.cell::before {
  content: "";
  position: absolute;
  inset: -8px;   /* grow hit area by 8px on all sides */
}
  .cell.hint{ outline:3px dashed #49e68b; animation: hintPulse 1.1s ease-in-out 2; }
  @keyframes hintPulse{
  0% {
    /* outline-offset:0;opacity:.9; */
    background-color: #d7ffe4;
  }
  50% {
    /* outline-offset:4px;opacity:1; */
    background-color: gold;
  }
  100% {
    /* outline-offset:0;opacity:.9;  */
    background-color: #d7ffe4
  }
  10%, 90% {
    transform: translate3d(-1px, 0, 0);
  }
  20%, 80% {
    transform: translate3d(2px, 0, 0);
  }
  30%, 50%, 70% {
    transform: translate3d(-4px, 0, 0);
  }
  40%, 60% {
    transform: translate3d(4px, 0, 0);
  }
}


  /* Word list */
  #bottom{position:fixed; left:0; right:0; bottom:0; z-index:20;
    padding:.6rem .7rem calc(.6rem + var(--sab));
    background:linear-gradient(to top, rgba(10,10,112,.95), rgba(10,10,120,.7) 50%, transparent)}
  #words{display:grid; grid-template-columns:repeat(2, minmax(140px,1fr)); gap:.4rem .6rem}
  .w{background:#1c222b;border:1px solid rgba(255,255,255,.12); border-radius:.7rem;
     padding:.42rem .6rem; font-weight:800; letter-spacing:.06em; display:flex; gap:.4rem; align-items:center}
  .w.done{opacity:.45}
  .w.allfound .circ{opacity:1; border-color:#87f59f}
  .w.allfound span:not(.circ){opacity:.35}
  .circ{display:inline-flex;align-items:center;justify-content:center;
    width:1.35em;height:1.35em;border-radius:999px;border:2px solid var(--accent);font-weight:900}

  /* H2H: show one target word (local/online) */
  .h2h #words{grid-template-columns:1fr}
  .h2h .w{display:none}
  .h2h .w.active{display:flex}

  /* Unscramble */
  #unsTop{display:none; height:100%; padding:.6rem .7rem;
    display:flex; flex-direction:column; align-items:center; justify-content:center}
  #unsSlots{display:flex; gap:.5rem; flex-wrap:wrap; margin:.6rem 0}
  .slot{ width:2.6rem; height:3.2rem; border-radius:.5rem;
    background:#141a21; border:2px solid rgba(255,255,255,.18);
    display:flex; align-items:center; justify-content:center; font-weight:900; font-size:1.45rem }
  #unsBank{display:flex; gap:.45rem; flex-wrap:wrap; }
  .chipL{background:#273141; border:1px solid rgba(255,255,255,.18);
    border-radius:.55rem; padding:.55rem .85rem; font-weight:900; cursor:pointer; color:#fff}
  #buzzRow{display:none; gap:.5rem; margin-top:.6rem; align-items:center; flex-wrap:wrap; justify-content:center}
  .buzz{background:#1e232a;border:1px solid rgba(255,255,255,.18); border-radius:.8rem;display:none;
    padding:.55rem .9rem; font-weight:900; cursor:pointer}
  .own{outline:2px solid var(--accent);}

  /* Settings modal */
  #cfg{ position:fixed; inset:0; z-index:40; display:flex; align-items:center; justify-content:center;
        background:rgba(0,0,0,.45); backdrop-filter:blur(6px); }
  #cfg[hidden]{ display:none; }
  #cfg .panel{ width:min(92vw,520px); background:#14151a; color:var(--fg);
    border:1px solid rgba(255,255,255,.14); border-radius:14px; padding:14px;
    box-shadow:0 10px 30px rgba(0,0,0,.45); }
  #cfg h3{ margin:.1rem 0 .7rem 0; }
  #cfg .row{ display:flex; align-items:center; justify-content:space-between; margin:.4rem 0; gap:.8rem; }
  #cfg select, #cfg input{
    background:#1c2027; color:var(--fg); border:1px solid rgba(255,255,255,.18);
    border-radius:10px; padding:.35rem .55rem; min-width:170px; font-weight:600;
  }
  #cfg .actions{ display:flex; justify-content:space-between; gap:.5rem; margin-top:.9rem; flex-wrap:wrap }
  #cfg .actions .left, #cfg .actions .right { display:flex; gap:.5rem; flex-wrap:wrap }

  .hide{display:none!important}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div id="btnStart" class="chip btn">‚ñ∂ Start</div>
    <div id="btnCfg" class="chip btn">‚öôÔ∏è Settings</div>
    <div id="hintBtn" class="chip btn">üí° Hint</div>
    <div id="timeChip" class="chip">‚è± <b id="hudTime">‚Äî</b> s</div>
    <div id="roomChip" class="chip" style="display:none">Room: <b id="hudRoom">‚Äî</b></div>
    <div class="chip pill">P1 ‚≠ê <b id="p1Score">0</b></div>
    <div id="p2Chip" class="chip pill">P2 ‚≠ê <b id="p2Score">0</b></div>
  </header>

  <div id="top">
    <div id="gridWrap"><div id="grid" aria-label="letter grid"></div></div>
    <div id="unsTop">
      <div id="unsSlots"></div>
      <div id="unsBank"></div>
      <div id="buzzRow">
        <button id="buzzP1" class="buzz">P1 Buzz</button>
        <button id="buzzP2" class="buzz">P2 Buzz</button>
        <div id="ownerMsg" style="opacity:.85"></div>
      </div>
      <div style="margin-top:.6rem;display:flex;gap:.5rem;flex-wrap:wrap">
        <button id="unsClear" class="chip btn">Clear</button>
        <button id="unsSubmit" class="chip btn">Submit</button>
      </div>
      <div id="unsMsg" style="margin-top:.4rem;min-height:1.2rem"></div>
    </div>

    <!-- Settings -->
    <div id="cfg" aria-modal="true" role="dialog" hidden>
      <div class="panel">
        <h3>Settings</h3>

        <label class="row">
          <span>Mode</span>
          <select id="cfgMode">
            <option value="solo">Solo</option>
            <option value="h2h_local">Head-to-Head (local test)</option>
            <option value="h2h_online">Head-to-Head (online)</option>
          </select>
        </label>

        <label class="row">
          <span>Difficulty</span>
          <select id="cfgDiff">
            <option>Easy</option><option>Normal</option><option>Hard</option><option>Expert</option><option>Zen</option>
          </select>
        </label>

        <label class="row">
          <span>Your Name</span>
          <input id="cfgName" placeholder="Player" value="Player">
        </label>

        <div class="actions">
          <div class="left">
            <button id="btnCreateRoom" class="chip btn">‚ûï Create Room</button>
            <button id="btnJoinRoom"   class="chip btn">üîó Join Room</button>
          </div>
          <div class="right">
            <button id="cfgCancel" class="chip btn">Cancel</button>
            <button id="cfgApply"  class="chip btn">Apply</button>
          </div>
        </div>

        <div style="opacity:.8;margin-top:.4rem" id="netStatus"></div>
      </div>
    </div>
  </div>

  <div id="bottom">
    <div id="words"></div>
  </div>
</div>

<script>
/* ========= tiny helpers ========= */
const $ = s => document.querySelector(s);
const hudTime=$('#hudTime'), p1ScoreEl=$('#p1Score'), p2ScoreEl=$('#p2Score'),
      gridEl=$('#grid'), wordsEl=$('#words'), hintBtn=$('#hintBtn'),
      timeChip=$('#timeChip'), p2Chip=$('#p2Chip'), roomChip=$('#roomChip'), hudRoom=$('#hudRoom');
const buzz = pat => ('vibrate' in navigator) && navigator.vibrate(pat);
  
/* ========= difficulty & base puzzle ========= */
const DIFFICULTY = {
  Easy:   { rows:10, cols:10, dirs:['H','V'],            backwards:false, words:6, searchSecs:null, hintAfter:8,  unscrambleSecs:20, dummies:0, mult:0.9, showHintBtn:true },
  Normal: { rows:12, cols:12, dirs:['H','V','D'],        backwards:'few', words:6, searchSecs:null, hintAfter:12, unscrambleSecs:25, dummies:0, mult:1.0, showHintBtn:false },
  Hard:   { rows:13, cols:13, dirs:['H','V','D'],        backwards:'more',words:7, searchSecs:null, hintAfter:16, unscrambleSecs:25, dummies:1, mult:1.2, showHintBtn:false },
  Expert: { rows:14, cols:14, dirs:['H','V','D'],        backwards:true,  words:8, searchSecs:null, hintAfter:null,unscrambleSecs:30, dummies:2, mult:1.4, showHintBtn:false },
  Zen:    { rows:12, cols:12, dirs:['H','V','D'],        backwards:false, words:6, searchSecs:null, hintAfter:6,  unscrambleSecs:60, dummies:0, mult:0.6, showHintBtn:true }
};
const PUZZLE_BASE = {
  words: [
    {text:'APPLE', takeIndex:1},
    {text:'RADIO', takeIndex:3},
    {text:'SCALE', takeIndex:1},
    {text:'CANDY', takeIndex:2},
    {text:'SKIRT', takeIndex:2},
    {text:'ICING', takeIndex:1}
  ],
  finalAnswer: 'PICNIC'
};

/* ========= state ========= */
const S = {
  diffName:'Easy', diff: DIFFICULTY.Easy,
  h2h:false, online:false,              // online => Supabase backed
  grid:[], rows:10, cols:10,
  placed:[], found:new Set(),
  circled:[],
  stage:'search', time:0, running:false, last:0,
  idle:0, hintLock:false,
  p:[0,0], curP:0,                       // local-only turn indicator
  dragging:false, startIdx:null, selPath:[],
  input:[], owner:null,

  // H2H sync helpers
  claimed: new Set(),                    // word indices we‚Äôve locked in
  unscrambleStarted:false,

  // seed for deterministic board (online)
  seed:null, useSeed:false, rng:null
};

/* ========= seeded RNG for online sync ========= */
function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t>>>15, t | 1); t ^= t + Math.imul(t ^ t>>>7, t | 61); return ((t ^ t>>>14) >>> 0) / 4294967296; }; }
function setRngSeed(seed){ S.seed = seed|0; S.rng = mulberry32(S.seed); S.useSeed = true; }
const R = () => (S.useSeed && S.rng ? S.rng() : Math.random());

/* ========= mode & HUD ========= */
function setMode(kind){
  // kind: 'solo' | 'h2h_local' | 'h2h_online'
  S.h2h = (kind !== 'solo');
  S.online = (kind === 'h2h_online');
  document.body.classList.toggle('h2h', S.h2h);

  // hints only in solo
  if (S.h2h) { hintBtn.style.display='none'; S.diff.hintAfter=null; }
  else { hintBtn.style.display=(S.diff.showHintBtn?'flex':'none'); S.diff.hintAfter=DIFFICULTY[S.diffName].hintAfter; }

  // P2 score only in H2H
  p2Chip.classList.toggle('hide', !S.h2h);
  // Room chip only online
  roomChip.style.display = S.online ? 'flex' : 'none';
}
function setDifficulty(name){ S.diffName = name; S.diff = DIFFICULTY[name]; }

/* ========= layout ========= */
function layout(){
  const head = document.querySelector('header'), bottom = document.querySelector('#bottom');
  const topEl = document.getElementById('top');
  if (!head || !bottom || !topEl) return;
  const headH=head.offsetHeight, bottomH=bottom.offsetHeight;
  const topH = Math.max(220, innerHeight - headH - bottomH - 10);
  topEl.style.top = headH + 'px';
  topEl.style.height = topH + 'px';
  gridEl.style.display='grid';
  gridEl.style.gridTemplateColumns = `repeat(${S.cols||10}, 1fr)`;
  const size = Math.min(innerWidth-16, topH-12);
  gridEl.style.width = size + 'px';
  gridEl.style.height = size + 'px';
}
addEventListener('resize', layout);
visualViewport?.addEventListener('resize', layout);

/* ========= board building ========= */
function allowedDirs(){
  const d=[]; if(S.diff.dirs.includes('H')) d.push([0,1],[0,-1]);
  if(S.diff.dirs.includes('V')) d.push([1,0],[-1,0]);
  if(S.diff.dirs.includes('D')) d.push([1,1],[-1,-1],[1,-1],[-1,1]);
  return d;
}
const idx=(r,c)=> r*S.cols+c;
const inb=(r,c)=> r>=0&&c>=0&&r<S.rows&&c<S.cols;
function buildEmpty(){ S.grid = Array(S.rows*S.cols).fill(''); }
function tryPlace(word){
  const W = word.text.toUpperCase(), dirs = allowedDirs();
  for(let attempt=0; attempt<260; attempt++){
    const dir = dirs[(R()*dirs.length)|0];
    const len=W.length, r0=(R()*S.rows)|0, c0=(R()*S.cols)|0;
    const r1=r0+dir[0]*(len-1), c1=c0+dir[1]*(len-1);
    if(!inb(r1,c1)) continue;
    let ok=true, path=[];
    for(let k=0;k<len;k++){
      const r=r0+dir[0]*k, c=c0+dir[1]*k, id=idx(r,c);
      const ch=S.grid[id]; if(ch && ch!==W[k]){ ok=false; break; }
      path.push(id);
    }
    if(!ok) continue;
    const back=S.diff.backwards;
    const revChance = back===true?0.5: back==='few'?0.25: back==='more'?0.5:0;
    const placeStr = (R()<revChance) ? [...W].reverse().join('') : W;
    for(let k=0;k<len;k++) S.grid[path[k]] = placeStr[k];
    S.placed.push({text:W, path, takeIndex:word.takeIndex});
    return true;
  }
  return false;
}
function fillRandom(){
  const LETTERS="EEEEEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNRRRRRSSSSTTTTTDLLLLUGGBBCCMMPPFFHHVVWWYKJXQZ";
  for(let i=0;i<S.grid.length;i++) if(!S.grid[i]) S.grid[i]=LETTERS[(R()*LETTERS.length)|0];
}

/* ========= render ========= */
function renderGrid(){
  gridEl.innerHTML='';
  for(let i=0;i<S.grid.length;i++){
    const d=document.createElement('div'); d.className='cell'; d.textContent=S.grid[i]; d.dataset.idx=i;
    gridEl.appendChild(d);
  }
  gridEl.style.gridTemplateColumns = `repeat(${S.cols||10}, 1fr)`;
}
function renderWordList(){
  wordsEl.innerHTML='';
  PUZZLE_BASE.words.forEach((w,i)=>{
    const row=document.createElement('div'); row.className='w'; row.id='w_'+i;
    row.innerHTML = w.text.toUpperCase().split('').map(ch=>`<span>${ch}</span>`).join('');
    wordsEl.appendChild(row);
  });
  updateActiveWordRow();
}

/* ========= active word (H2H) ========= */
function nextUnclaimedIndex(){
  for(let i=0;i<PUZZLE_BASE.words.length;i++) if(!S.claimed.has(i)) return i;
  return null;
}
function updateActiveWordRow(){
  if(!S.h2h) return;
  document.querySelectorAll('#words .w').forEach(w=>w.classList.remove('active'));
  const n = nextUnclaimedIndex();
  if (n!=null) document.getElementById('w_'+n)?.classList.add('active');
}

/* ========= selection helpers ========= */
function rcFromIdx(id){ return [(id/S.cols)|0, id%S.cols]; }
function dirOf(a,b){
  const [ar,ac]=rcFromIdx(a), [br,bc]=rcFromIdx(b);
  const dr=Math.sign(br-ar), dc=Math.sign(bc-ac);
  if(dr===0&&dc===0) return null;
  if(dr!==0&&dc!==0 && Math.abs(br-ar)!==Math.abs(bc-ac)) return null;
  return [dr,dc];
}
function cellsBetween(a,b){
  const d=dirOf(a,b); if(!d) return null;
  const [ar,ac]=rcFromIdx(a), [br,bc]=rcFromIdx(b); const n=Math.max(Math.abs(br-ar),Math.abs(bc-ac))+1, out=[];
  for(let k=0;k<n;k++){ const r=ar+d[0]*k, c=ac+d[1]*k; out.push(idx(r,c)); } return out;
}
function setSel(on,list){ for(const id of list){ gridEl.children[id]?.classList.toggle('sel',on); } }
function wordFrom(list){ return list.map(i=>S.grid[i]).join(''); }
function findPlacedByPath(list){
  const fwd=wordFrom(list), rev=wordFrom([...list].reverse());
  if (S.h2h){
    const n = nextUnclaimedIndex(); if(n==null) return null;
    const target=PUZZLE_BASE.words[n].text.toUpperCase();
    if (fwd===target || rev===target) return { placed:S.placed[n], wIdx:n };
    return null;
  } else {
    const p = S.placed.findIndex(p=>!S.found.has(p.text) && (p.text===fwd || p.text===rev));
    return (p>=0) ? { placed:S.placed[p], wIdx:p } : null;
  }
}

/* ========= hints (solo only) ========= */
function showHint(){
  if (S.stage !== 'search' || S.h2h) return;          // Solo only
  S.hintLock = true; setTimeout(()=> S.hintLock = false, 2600);

  // only words not yet claimed
  const pool = S.placed
    .map((p, i) => ({ p, i }))
    .filter(({ i }) => !S.claimed.has(i));
  if (!pool.length) return;

  const pick = pool[(R() * pool.length) | 0].p;
  const id = pick.path[pick.takeIndex ?? ((R() * pick.path.length) | 0)];
  const cell = gridEl.children[id];
  if (cell){
    cell.classList.add('hint');
    setTimeout(()=> cell.classList.remove('hint'), 1400);
  }
}
hintBtn.onclick = showHint;

function refreshHintVisibility() {
  // show only in SOLO + SEARCH stage + this difficulty actually has hints
  const canShow = !S.h2h && S.stage === 'search' && DIFFICULTY[S.diffName].showHintBtn;
  hintBtn.style.display = canShow ? 'flex' : 'none';
}
/* ========= run content ========= */
let CUR = { words:[], finalAnswer:'', unscrambleSecs:25 };
function makeRun(){
  CUR.words = PUZZLE_BASE.words.map(w=>({...w}));
  CUR.finalAnswer = PUZZLE_BASE.finalAnswer;
  CUR.unscrambleSecs = S.h2h ? null : (DIFFICULTY[S.diffName].unscrambleSecs);
}

/* ========= scoring ========= */
function updateScores(){ p1ScoreEl.textContent=S.p[0]; p2ScoreEl.textContent=S.p[1]; }
function scoreWord(len, player){ const pts=Math.round(5*len*(S.diff.mult||1)); if(S.h2h) S.p[player]+=pts; else S.p[0]+=pts; updateScores(); }
function scoreBonus(bonus, player){ const pts=Math.round(bonus*(S.diff.mult||1)); if(S.h2h) S.p[player]+=pts; else S.p[0]+=pts; updateScores(); }

/* ========= claim flow (works for local & online) ========= */
function handleClaim(wIdx, byPid){
  if (S.claimed.has(wIdx)) return;      // idempotent
  S.claimed.add(wIdx);

  // paint grid path
  const placed = S.placed[wIdx];
  if (!S.h2h && placed?.text) S.found.add(placed.text);
  if (placed){
    for(const id of placed.path){
      const cell = gridEl.children[id];
      if (cell){ cell.classList.remove('sel'); cell.classList.add('found'); }
    }
  }
  // row visuals
  const row = document.getElementById('w_'+wIdx);
  if (row){
    row.classList.add('done');
    if (byPid==='p2') row.style.borderColor = '#ff9aa9';
    if (byPid==='p1') row.style.borderColor = '#9affc7';
  }

  // scoring (who gets points?)
  if (S.h2h){
    if (S.online){
      const me = Net.me();                           // {roomId, pid}
      const awardTo = (byPid === 'p1') ? 0 : 1;      // p1 -> index 0, p2 -> index 1
      scoreWord((placed?.text?.length||5), awardTo);
    } else {
      // local test alternates by turn owner
      const awardTo = (S.curP===0)?0:1;
      scoreWord((placed?.text?.length||5), awardTo);
    }
  } else {
    scoreWord((placed?.text?.length||5), 0);
  }

  // advance target for everyone
  updateActiveWordRow();

  // if all claimed ‚Üí unscramble
  if (nextUnclaimedIndex() == null && !S.unscrambleStarted){
    S.unscrambleStarted = true;
    endSearchStartUnscramble();
  }
}

/* ========= build game ========= */
function buildGame(){
  S.rows = S.diff.rows; S.cols = S.diff.cols;
  makeRun();

  S.grid.length=0; S.placed.length=0; S.found.clear(); S.circled.length=0;
  S.claimed.clear(); S.unscrambleStarted=false;
  S.stage='search'; hudTime.textContent='‚Äî';
  S.idle=0; S.hintLock=false; S.p=[0,0]; S.curP=0; updateScores();
  $('#gridWrap').style.display='flex'; $('#unsTop').style.display='none';
  $('#buzzRow').style.display = S.h2h ? 'flex' : 'none'; setOwner(null);

  if (S.online && !S.useSeed){
    // if somehow online but missing seed, generate temp to avoid crash
    setRngSeed((Math.random()*2_000_000_000)|0);
  }

  for(let tries=0; tries<80; tries++){
    buildEmpty(); S.placed.length=0;
    let ok=true; for(const w of PUZZLE_BASE.words){ if(!tryPlace(w)){ ok=false; break; } }
    if(ok) break;
  }
  fillRandom(); renderGrid(); renderWordList(); layout();
  refreshHintVisibility();
}

/* ========= input (search) ========= */
function markInteraction(){ S.idle=0; }
['pointerdown','pointermove','keydown','click','touchstart'].forEach(ev=>addEventListener(ev,markInteraction,{passive:true}));

gridEl.addEventListener('pointerdown', e=>{
  if (S.stage!=='search') return;
  const el=e.target.closest('.cell'); if(!el) return;
  S.dragging=true; S.selPath.length=0; S.startIdx=+el.dataset.idx;
  S.selPath=[S.startIdx]; setSel(true,S.selPath);
  gridEl.setPointerCapture?.(e.pointerId); e.preventDefault();
},{passive:false});
gridEl.addEventListener('pointermove', e=>{
  if(!S.dragging || S.stage!=='search') return;
  const el=document.elementFromPoint(e.clientX,e.clientY)?.closest('.cell'); if(!el) return;
  const id=+el.dataset.idx; if(id===S.startIdx) return;
  const seq=cellsBetween(S.startIdx,id); if(!seq) return;
  setSel(false,S.selPath); S.selPath=seq; setSel(true,S.selPath);
  e.preventDefault();
},{passive:false});
addEventListener('pointerup', e=>{
  if(!S.dragging) return; S.dragging=false;
  if(!S.selPath.length) return;
  const found = findPlacedByPath(S.selPath);
  if(found){
    const { placed, wIdx } = found;
    // local immediate claim
    const myPid = S.h2h ? (S.online ? (Net.me().pid) : (S.curP===0?'p1':'p2')) : 'p1';
    handleClaim(wIdx, myPid);
    // broadcast if online
    if (S.h2h && S.online && Net.me().roomId) Net.signalFound(wIdx);
    // local test: flip turn
    if (S.h2h && !S.online) S.curP = 1 - S.curP;
    buzz(12);
  } else {
    buzz([2,40,2]); setSel(false,S.selPath);
  }
  S.selPath.length=0;
});

/* ========= H2H: buzz ownership for typing ========= */
$('#buzzP1').onclick = ()=> setOwner(0);
$('#buzzP2').onclick = ()=> setOwner(1);
function setOwner(p){
  S.owner = p;
  $('#ownerMsg').textContent = (p==null) ? '' : `P${p+1} typing‚Ä¶`;
  $('#buzzP1').classList.toggle('own', p===0);
  $('#buzzP2').classList.toggle('own', p===1);
}

/* ========= stage ‚Üí unscramble ========= */
function endSearchStartUnscramble(){
  // reveal circled letters in list
  S.circled = PUZZLE_BASE.words.map(w => w.text[w.takeIndex]).filter(Boolean);
  document.querySelectorAll('#words .w').forEach((row, i)=>{
    const w = PUZZLE_BASE.words[i].text.toUpperCase(), k = PUZZLE_BASE.words[i].takeIndex|0;
    row.innerHTML = w.split('').map((ch,j)=> j===k? `<span class="circ">${ch}</span>`:`<span>${ch}</span>`).join('');
    row.classList.add('allfound');
  });

  $('#gridWrap').style.display='none';
  $('#unsTop').style.display='flex';
  S.stage='unscramble';

  refreshHintVisibility();        // ‚Üê add this

  buildUnscramble();
  S.time = (S.h2h ? 0 : (DIFFICULTY[S.diffName].unscrambleSecs||0));
  S.running = !!S.time;
  hudTime.textContent = S.running? Math.ceil(S.time) : '‚Äî';
  if (S.h2h) setOwner(S.curP);
}

/* ========= unscramble ========= */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=((S.useSeed?Math.floor(R()*(i+1)):(Math.random()*(i+1)))|0); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function buildUnscramble(){
  const slots=$('#unsSlots'), bank=$('#unsBank'), msg=$('#unsMsg');
  slots.innerHTML=''; bank.innerHTML=''; msg.textContent=''; S.input.length=0;

  const letters=[...S.circled];
  const dummies=S.diff.dummies|0;
  const pool="ETAOINSHRDLUCMWFGYPBVKJXQZ";
  for(let i=0;i<dummies;i++) letters.push(pool[(R()*pool.length)|0]);
  shuffle(letters);

  for (let i=0;i<PUZZLE_BASE.finalAnswer.length;i++){
    const s=document.createElement('div'); s.className='slot'; s.dataset.i=i; slots.appendChild(s);
  }
  letters.forEach((ch,i)=>{
    const b=document.createElement('button'); b.className='chipL'; b.textContent=ch; b.dataset.i=i;
    b.onclick=()=> pickFromBank(i); bank.appendChild(b);
  });
}
function pickFromBank(i){
  if (S.h2h && S.owner==null) return;
  const btn = $('#unsBank').querySelector(`.chipL[data-i="${i}"]`);
  if (!btn || btn.disabled) return;
  const k = S.input.length; if (k >= PUZZLE_BASE.finalAnswer.length) return;
  S.input.push(btn.textContent);
  $('#unsSlots').children[k].textContent = btn.textContent;
  btn.disabled = true; btn.style.opacity = .4; buzz(8);
}
$('#unsClear').onclick = ()=>{ S.input.length=0; for(const s of $('#unsSlots').children) s.textContent=''; for(const b of $('#unsBank').children){ b.disabled=false; b.style.opacity=1; } };
$('#unsSubmit').onclick = ()=>{
  const guess=S.input.join('').toUpperCase();
  if (guess.length !== PUZZLE_BASE.finalAnswer.length){ setUnsMsg('Incomplete', false); buzz([2,40,2]); return; }
  if (guess === PUZZLE_BASE.finalAnswer.toUpperCase()){
    const bonus = Math.max(0, Math.ceil(S.time)) * 10;
    const winner = S.h2h ? (S.owner ?? S.curP) : 0;
    scoreBonus(bonus, winner);
    setUnsMsg(`Correct! +${bonus} ‚≠ê to P${winner+1}`, true);
    S.running=false; setOwner(null); buzz([10,40,10]);
  } else { setUnsMsg('Try again', false); buzz([2,40,2]); if (S.h2h) setOwner(null); }
};
function setUnsMsg(t, ok){ const el=$('#unsMsg'); el.textContent=t; el.style.color = ok? '#87f59f' : '#ff6b6b'; }

/* ========= tick ========= */
function tick(now){
  if (!now) now=performance.now();
  const dt = S.last ? (now - S.last)/1000 : 0; S.last = now;

  if (S.stage==='search'){
    hudTime.textContent='‚Äî';
    if (!S.h2h && S.diff.hintAfter && !S.hintLock){ S.idle+=dt; if(S.idle>=S.diff.hintAfter){ showHint(); S.idle=0; } }
  } else if (S.stage==='unscramble'){
    if (!S.h2h && S.running){ S.time -= dt; if (S.time<=0){ S.time=0; S.running=false; setUnsMsg('Time!', false); } hudTime.textContent=Math.ceil(S.time); }
    else { hudTime.textContent='‚Äî'; }
  }
  requestAnimationFrame(tick);
}

/* ========= UI wiring ========= */
$('#btnStart').onclick = ()=>{ buildGame(); tick(); };
$('#btnCfg').onclick = ()=>{
  $('#cfgMode').value = S.online? 'h2h_online' : (S.h2h? 'h2h_local':'solo');
  $('#cfgDiff').value = S.diffName;
  $('#cfgName').value = localStorage.getItem('war_name') || 'Player';
  $('#cfg').hidden = false;
};
$('#cfgCancel').onclick = ()=> $('#cfg').hidden = true;
$('#cfgApply').onclick = ()=>{
  const mode = $('#cfgMode').value, diff = $('#cfgDiff').value, name = ($('#cfgName').value||'Player').trim() || 'Player';
  localStorage.setItem('war_name', name);
  setMode(mode); setDifficulty(diff); if(!S.online) S.useSeed=false;
  buildGame(); $('#cfg').hidden = true;
};

/* ========= Supabase net layer ========= */
const Net = (()=>{
  const ROOM_ALPH='ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  const makeRoomId=(n=6)=> Array.from({length:n},()=>ROOM_ALPH[(Math.random()*ROOM_ALPH.length)|0]).join('');
  let roomId=null, pid=null, chClaims=null, chRooms=null;

  async function fetchSnapshot(id){
    const [r,p,c]=await Promise.all([
      sb.from('rooms').select('*').eq('id',id).single(),
      sb.from('room_players').select('*').eq('room_id',id),
      sb.from('room_claims').select('*').eq('room_id',id)
    ]);
    if (r.error) throw r.error;
    const foundBy={}; (c.data||[]).forEach(row=>{ foundBy[row.word_idx]=row.by_pid; });
    return { room:r.data, players:p.data||[], foundBy };
  }
  async function createRoom(displayName){
    const id = makeRoomId(), seed=(Math.random()*2_000_000_000)|0;
    const e1=await sb.from('rooms').insert({id,seed,mode:'H2H',status:'lobby'}); if(e1.error) throw e1.error;
    const e2=await sb.from('room_players').insert({room_id:id,pid:'p1',name:displayName}); if(e2.error) throw e2.error;
    roomId=id; pid='p1'; return {roomId:id, seed, pid};
  }
  async function joinRoom(id, displayName){
    const snap = await fetchSnapshot(id); if(!snap.room) throw new Error('Room not found');
    const hasP1=snap.players.some(p=>p.pid==='p1'), hasP2=snap.players.some(p=>p.pid==='p2');
    const myPid = hasP1 && !hasP2 ? 'p2' : (!hasP1 ? 'p1' : 'p2');
    const up=await sb.from('room_players').upsert({room_id:id,pid:myPid,name:displayName},{onConflict:'room_id,pid'}); if(up.error) throw up.error;
    roomId=id; pid=myPid;
    return { roomId:id, seed:snap.room.seed, pid:myPid, foundBy:snap.foundBy };
  }
  async function setStatusPlaying(){ if(!roomId) return; await sb.from('rooms').update({status:'playing'}).eq('id',roomId); }
  async function signalFound(wordIdx){
    if(!roomId||!pid) return;
    const res=await sb.from('room_claims').insert({room_id:roomId, word_idx:wordIdx, by_pid:pid});
    if(res.error && res.error.code!=='23505') console.warn('claim error', res.error);
  }
  async function subscribe(handlers){
    chClaims = sb.channel('claims_'+roomId).on('postgres_changes',{
      event:'INSERT', schema:'public', table:'room_claims', filter:`room_id=eq.${roomId}`
    }, payload=>{
      handlers?.onClaim?.(payload.new.word_idx, payload.new.by_pid);
    }).subscribe();
    chRooms = sb.channel('rooms_'+roomId).on('postgres_changes',{
      event:'UPDATE', schema:'public', table:'rooms', filter:`id=eq.${roomId}`
    }, payload=>{
      handlers?.onRoomUpdate?.(payload.new);
    }).subscribe();
    const snap = await fetchSnapshot(roomId);
    return snap;
  }
  async function leave(){ if(chClaims) await sb.removeChannel(chClaims); if(chRooms) await sb.removeChannel(chRooms); roomId=null; pid=null; }
  const me = ()=>({roomId,pid});
  return { createRoom, joinRoom, setStatusPlaying, signalFound, subscribe, leave, me };
})();

/* ========= online create/join (Settings) ========= */
$('#btnCreateRoom').onclick = async ()=>{
  const name = ($('#cfgName').value||'Player').trim() || 'Player';
  try{
    const { roomId, seed, pid } = await Net.createRoom(name);
    setMode('h2h_online'); setRngSeed(seed); buildGame();
    hudRoom.textContent = `${roomId} ¬∑ ${pid.toUpperCase()}`; roomChip.style.display='flex';
    $('#netStatus').textContent = `Room created. Share code: ${roomId}`;
    await Net.setStatusPlaying();
    const snap = await Net.subscribe({
      onClaim: (idx, by)=> handleClaim(idx, by),
      onRoomUpdate: (room)=> { /* optional */ }
    });
    // hydrate existing claims
    for (const [i, by] of Object.entries(snap.foundBy)) handleClaim(+i, by);
  }catch(err){ $('#netStatus').textContent = 'Create failed: '+err.message; }
};
$('#btnJoinRoom').onclick = async ()=>{
  const name = ($('#cfgName').value||'Player').trim() || 'Player';
  const code = prompt('Enter room code:')?.trim().toUpperCase();
  if (!code) return;
  try{
    const { seed, pid, foundBy } = await Net.joinRoom(code, name);
    setMode('h2h_online'); setRngSeed(seed); buildGame();
    hudRoom.textContent = `${code} ¬∑ ${pid.toUpperCase()}`; roomChip.style.display='flex';
    $('#netStatus').textContent = `Joined ${code} as ${pid.toUpperCase()}`;
    const snap = await Net.subscribe({
      onClaim: (idx, by)=> handleClaim(idx, by),
      onRoomUpdate: (room)=> { /* optional */ }
    });
    // hydrate claims that already exist
    for (const [i, by] of Object.entries(foundBy)) handleClaim(+i, by);
  }catch(err){ $('#netStatus').textContent = 'Join failed: '+err.message; }
};

/* ========= boot ========= */
setMode('solo'); setDifficulty('Easy'); buildGame(); layout(); tick();
</script>
</body>
</html>










