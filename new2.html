<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  /* stop iOS font inflation */
  html { -webkit-text-size-adjust:100%; text-size-adjust:100%; }
</style>
<title>Word-a-Roo</title>

<!-- GitHub Pages: project site base (edit if repo name changes) -->
<base href="/word-search-proto/">

<style>
:root{
  --bg:#0c1015; --fg:#e9eef4;
  --panelW:clamp(320px,92vw,760px);
  --panelPad:14px;
}

/* base */
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
  font:600 16px/1.25 system-ui,-apple-system,Segoe UI,Inter,Roboto,Helvetica,Arial,sans-serif;}
button{font:inherit}
.hide{display:none!important}

/* ---------- header chips ---------- */
header{position:fixed;left:0;right:0;top:0;display:flex;gap:.6rem;align-items:center;
  padding:.55rem .7rem;z-index:50;pointer-events:none}
.chip{pointer-events:auto;background:rgba(20,20,22,.72);border:1px solid rgba(255,255,255,.12);
  backdrop-filter: blur(8px); border-radius:14px; padding:.38rem .65rem;display:flex;gap:.45rem;
  align-items:center;font-weight:800}

/* ---------- splash ---------- */
#splash{position:fixed;inset:0;background:#000}
#splash.hidden{display:none}
#splash img.bg{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;opacity:.9}
#btnStart{
  position:absolute; left:max(30px, env(safe-area-inset-left));
  bottom:max(30px, env(safe-area-inset-bottom));
  appearance:none;border:none;border-radius:999px;padding:14px 22px;
  background:#0a7bd1;color:#fff;font-weight:900;letter-spacing:.02em;
  box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 -3px 0 rgba(0,0,0,.25); cursor:pointer
}
#btnStart:active{ transform:translateY(1px) }
@media (prefers-reduced-motion:no-preference){
  @keyframes pulse {0%{transform:scale(1);box-shadow:0 0 0 0 rgba(10,123,209,.45)}
    70%{transform:scale(1.03);box-shadow:0 0 0 14px rgba(10,123,209,0)}100%{transform:scale(1)}}
  #btnStart{ animation:pulse 1.6s ease-in-out infinite }
}

/* ===================== game container (NOT full-screen) ===================== */
/* sits under the header, centered, with bottom breathing room for future UI */

/* centers the whole card under the header and gives it a fixed play area */
#gameWrap{
  position:fixed;
  left:50%;
  top:56px;                                /* header height */
  transform:translateX(-50%);
  width:var(--panelW);                      /* your clamp(320px,92vw,760px) */
  height:calc(100svh - 56px - 18px);        /* stable viewport height (iOS-safe) */
  display:flex;
  justify-content:center;
  align-items:flex-start;
  z-index:1;
}
  
/* gradient frame */
#gameCard{
  display:flex;
  flex-direction:column;
  gap:10px;
  width:100%;
  height:auto;

  /* same rounded corners for all */
  border-radius:34px;

  background:
    linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02)) padding-box,
    linear-gradient(90deg, #1b2a8f, #a24bff) border-box;
  border:9px solid transparent;

  box-shadow:0 20px 50px rgba(0,0,0,.35),
             inset 0 1px 0 rgba(255,255,255,.12);

  /* ‚úÖ clipping fixes */
  overflow:hidden;                                 /* normal clip */
  clip-path: inset(0 round 34px);                  /* forces radius on iOS */
  -webkit-mask-image: -webkit-radial-gradient(white, black);
}

/* ---------- word list (top slab) ---------- */
#wordBar{
  background:#fff; color:#000;
  border:1px solid rgba(0,0,0,.10);
  padding:10px var(--panelPad);
  border-top-left-radius:24px; border-top-right-radius:24px;
  border-bottom-left-radius:8px; border-bottom-right-radius:8px;
  box-shadow:0 1px 0 rgba(0,0,0,.06) inset, 0 6px 16px rgba(0,0,0,.05);
}
#wordList{
  display:grid;
  grid-template-columns:repeat(3, 1fr);
  gap:8px;
  text-align:center;
  white-space:nowrap;     /* keep each word intact */
}
#wordList b{ font-weight:900 } #wordList .done{ opacity:.35 }

/* ---------- messages lane (middle) ---------- */
#msgArea{
  min-height:58px; display:grid; place-items:center; gap:6px; text-align:center;
  background:linear-gradient(180deg, rgba(130,130,160,.45), rgba(130,130,160,.2));
  border-left:1px solid rgba(0,0,0,.08); border-right:1px solid rgba(0,0,0,.08);
}
/* fine-tune vertical alignment of the message zone */
#msgArea{
  position:relative;
  min-height:72px;                     /* stable lane height */
  display:grid; place-items:center; gap:6px; text-align:center;
  background:linear-gradient(180deg, rgba(130,130,160,.45), rgba(130,130,160,.2));
  border-left:1px solid rgba(0,0,0,.08); border-right:1px solid rgba(0,0,0,.08);
}

#liveWord{
  display:inline-flex; gap:.05em; letter-spacing:.1em;
  font-size:clamp(28px,7vw,48px); color:#fff; text-shadow:0 2px 6px rgba(0,0,0,.5)
}
#liveWord .ch{ display:inline-block; transform-origin:50% 60%; animation:pop .22s cubic-bezier(.2,.8,.2,1) }
@keyframes pop{ 0%{transform:scale(.6);opacity:0} 60%{transform:scale(1.12);opacity:1} 100%{transform:scale(1)} }
#msgStack{ display:grid; gap:6px }
/* praise overlays the lane ‚Äî no layout impact */
#msgStack{
  position:absolute; inset:0;
  display:grid; align-content:center; justify-items:center; gap:6px;
  pointer-events:none;
}
.msg{ background:rgba(0,0,0,.78); color:#fff; border-radius:999px; padding:6px 14px; font-weight:900; animation:riseFade .9s ease forwards }
.msg.good{ background:#0a7bd1 } .msg.bad{ background:#b00020 } .msg.mega{ font-size:clamp(28px,8vw,56px); letter-spacing:.06em; padding:8px 18px }
@keyframes riseFade{ 0%{opacity:0;transform:translateY(8px)} 60%{opacity:1;transform:translateY(0)} 100%{opacity:0;transform:translateY(-6px)} }

/* ---------- board (bottom slab) ---------- */
#board{ display:grid; place-items:center }
.cardOriginal{
  position:relative; width:100%; height:100%;
  background:#fff; border:1px solid rgba(0,0,0,.12);
  border-top-left-radius:8px; border-top-right-radius:8px;
  border-bottom-left-radius:24px; border-bottom-right-radius:24px;
  padding:18px; 
  overflow:hidden;                     /* fallback clip */
  /* enforce clipping of absolutely-positioned children (iOS fix) */
  clip-path: inset(0 round 8px 8px 24px 24px);
  -webkit-mask-image: -webkit-radial-gradient(white, black); /* belt & suspenders */
  display:grid; place-items:center;
  box-shadow:0 0 0 1px rgba(0,0,0,.02) inset, 0 10px 24px rgba(0,0,0,.08);
}
.card{
  position:relative;
  width:100%; height:100%;
  background:#fff;
  border:1px solid rgba(0,0,0,.12);
  border-radius:34px;              /* match parent frame */
  padding:18px;
  display:grid; place-items:center;
  overflow:hidden;
  clip-path: inset(0 round 34px);  /* iOS Safari fix */
  -webkit-mask-image: -webkit-radial-gradient(white, black);
  box-shadow:0 0 0 1px rgba(0,0,0,.02) inset,
             0 10px 24px rgba(0,0,0,.08);
}
/* overlays for pills */
#bands, #bandsPreview{
  position:absolute; inset:18px; pointer-events:none;
}
.band{ position:absolute; border-radius:9999px; opacity:.92 }
.band.preview{ background:#cdb8ff; opacity:.55; filter:saturate(1.1) }
.band.pink{background:#F59CB0} .band.purple{background:#C8B6FF} .band.green{background:#A8F5A6}
.band.gold{background:#FFD166} .band.blue{background:#9ADAFE} .band.orange{background:#FFB07C}

/* grid */
/* grid */
#grid{
  position:relative;
  display:grid;
  gap:10px;                      /* keep in sync with JS 'gap' below */
  user-select:none; touch-action:none;
  width:100%;
  max-width:680px;               /* hard cap so it can‚Äôt balloon */
  margin-inline:auto;
}

/* cells: use --cell from JS, not vw */
.cell{
  display:grid; place-items:center; background:transparent; color:#000; font-weight:900;
  width:var(--cell,56px); height:var(--cell,56px);
  border-radius:16px;

  /* letters follow the cell size (no vw) */
  font-size:calc(var(--cell,56px) * 0.58);
}
.cell.sel{ outline:3px solid #5fb5ff; outline-offset:2px; background:#f1f6ff }

/* (Optional) keep your pseudo hint; if Safari misbehaves we‚Äôll swap to overlay later */
.cell.hint{ position:relative }
.cell.hint::after{ content:""; position:absolute; inset:-4px; border-radius:18px; border:3px dashed #0a7bd1; animation:pulseHint 1s ease-in-out infinite }
@keyframes pulseHint{ 0%{opacity:.2} 50%{opacity:1} 100%{opacity:.2} }
/* confetti */
#confetti{position:fixed;inset:0;pointer-events:none;overflow:hidden;z-index:80}
#confetti i{position:absolute;width:10px;height:10px;background:#fff;opacity:.9;animation:fall 1200ms linear forwards}
@keyframes fall{to{transform:translateY(110vh) rotate(720deg);opacity:.2}}

/* high-contrast toggle */
.hc .cell{color:#000}
.hc #wordBar{background:#000;color:#fff;border-color:#333}

/* Modal (simple) */
  #modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;place-items:center;z-index:60}
  #modal.show{display:grid}
  .panel{background:#16181d;color:#fff;border:1px solid rgba(255,255,255,.12);border-radius:18px; padding:16px; width:min(92vw,460px)}
  .row{display:flex;align-items:center;justify-content:space-between;padding:10px 6px}
  .panel .close{margin-top:10px;width:100%}
/* game container: keep a little breathing room at the bottom */
#gameWrap{
  height:calc(100svh - 56px - max(12px, env(safe-area-inset-bottom)));
}

/* message lane: smaller default height */
#msgArea{
  min-height:clamp(44px, 8vw, 64px);
}

/* card: slightly tighter vertical padding on phones */
@media (max-width: 420px){
  .card{ padding:14px 18px 16px; }
}

/* grid: tighter gap on small screens */
@media (max-width: 420px){
  #grid{ gap:8px; }
}
</style>
</head>
<body>

<!-- Splash -->
<section id="splash" aria-label="Splash">
  <img class="bg" id="splashImg" alt="Splash" src="assets/img/splash.png">
  <button id="btnStart">‚ñ∂ Start</button>
</section>

<!-- HUD -->
<header>
  <div id="btnCfg" class="chip">‚öôÔ∏è Settings</div>
  <div id="btnHint" class="chip">üí° Hint</div>
  <div class="chip">Level <span id="lvl">1</span></div>
</header>

<!-- GAME: container with three lanes -->
<main id="gameWrap" class="hide">
  <div id="gameCard">
    <!-- TOP -->
    <div id="wordBar"><div id="wordList"></div></div>
    <!-- MIDDLE -->
    <section id="msgArea">
      <div id="liveWord"></div>
      <div id="msgStack" aria-live="polite"></div>
    </section>
    <!-- BOTTOM -->
    <div id="board">
      <div class="card">
        <div id="bandsPreview"></div>
        <div id="bands"></div>
        <div id="grid" aria-label="letter grid"></div>
      </div>
    </div>
  </div>
</main>

<!-- Settings -->
<div id="modal">
  <div class="panel">
    <h3 style="margin:0 0 8px 0">Settings</h3>
    <div class="row"><label>Snake Charmer (curving paths)</label><input type="checkbox" id="optSnake" checked></div>
    <div class="row"><label>Haptics</label><input type="checkbox" id="optHaptics" checked></div>
    <div class="row"><label>Tones on drag</label><input type="checkbox" id="optTones" checked></div>
    <div class="row"><label>Reduced sensory</label><input type="checkbox" id="optHC"></div>
    <button class="close">Close</button>
  </div>
</div>

<div id="confetti"></div>

<script>
/* ---------- Assets (base tag handles the /word-search-proto/ prefix) ---------- */
const ASSETS = {
  img:   { splash:'assets/img/splash.png', search:'assets/img/search.png' },
  audio: { splash:'assets/audio/splash.mp3', search:'assets/audio/search.mp3', victory:'assets/audio/victory.mp3' }
};

/* ---------- Tiny audio helper (unlocked once) ---------- */
const Snd = (() => {
  const aSplash = new Audio(ASSETS.audio.splash);
  const aLoop   = new Audio(ASSETS.audio.search); aLoop.loop=true; aLoop.volume=.55;
  const aWin    = new Audio(ASSETS.audio.victory);
  let unlocked=false, ctx=null;

  async function unlockOne(src){ try{ const a=new Audio(src); await a.play(); a.pause(); }catch{} }
  async function userInit(){
  if (unlocked) return;
  try{
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    await ctx.resume();                 // silent unlock
    // just preload (no play)
    [aSplash,aLoop,aWin].forEach(a=>a.load());
  }catch{}
  unlocked = true;
}
  async function playSplash(){ try{ aSplash.currentTime=0; await aSplash.play(); }catch{} }
  async function startLoop(){ try{ aLoop.currentTime=0; await aLoop.play(); }catch{} }
  function stopAll(){ [aSplash,aLoop,aWin].forEach(a=>{ try{a.pause()}catch{} }); }
  async function victory(){ try{ aWin.currentTime=0; await aWin.play(); }catch{} }

  // tiny tone + haptic
  function tone(freq=440, dur=0.06){
    if (!S.settings.tones || !ctx) return;
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.connect(g).connect(ctx.destination); o.type='sine'; o.frequency.value=freq;
    const t=ctx.currentTime; g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(0.2,t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.start(t); o.stop(t+dur+0.02);
  }
  function haptic(ms=8){ if (S.settings.haptics && navigator.vibrate) navigator.vibrate(ms); }

  return { userInit, playSplash, startLoop, stopAll, victory, tone, haptic };
})();

/* ---------- Data ---------- */
const WORDS = ['BIRD','BUG','CLOUD','DRAGON','KITE','EMIT'];
const DICT = new Set(['BIRD','BUG','CLOUD','DRAGON','KITE','EMIT','TIME','TIDE','TREE','STONE','RING','ROAD','RAIN','WIND','FIRE','WATER','EARTH','AIR','SUN','STAR','MOON']);

/* ---------- State ---------- */
const S = {
  level:1, rows:7, cols:6, grid:[], placed:[], foundIdx:new Set(), bonusWords:new Set(),
  dragging:false, selPath:[], settings:{ snake:true, haptics:true, tones:true, highContrast:false },
  bandColors:['pink','purple','green','gold','blue','orange']
};
S.curDir = [0,0];        // current snapped direction (dr,dc)
S.segLen = 0;            // cells traveled in current segment
S.minTurnLen = 1;        // require 2 cells straight before turning
/* ---------- DOM ---------- */
const $ = s => document.querySelector(s);
const splash = $('#splash'), gridEl = $('#grid'), bandsEl = $('#bands'), previewEl = $('#bandsPreview');
const wordList = $('#wordList'), lvlEl = $('#lvl'), gameWrap = $('#gameWrap');

/* ---------- Helpers ---------- */
const R = n => Math.floor(Math.random()*n);
const idx=(r,c)=> r*S.cols+c, inb=(r,c)=> r>=0&&c>=0&&r<S.rows&&c<S.cols;
const rcOf=id=> [(id/S.cols)|0, id%S.cols];
function lettersOf(path){ return path.map(id=>S.grid[id]).join(''); }
// screen-space center for a grid cell
// center point of a cell in client coords
function cellCenterClient(id){
  const r = gridEl.children[id].getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}
// snap any angle to one of 8 unit directions
function snapDir(dx, dy){
  if (dx===0 && dy===0) return [0,0];
  const a = Math.atan2(dy, dx);              // -PI..PI
  // 8-way bins every 45¬∞ centered on axes (¬±22.5¬∞ tolerance)
  const step = Math.PI / 4;                  // 45¬∞
  const bin  = Math.round(a / step);
  const dir  = bin % 8;
  // map bin ‚Üí (dr,dc)
  const map = [
    [ 0, 1],  // 0: ‚Üí
    [-1, 1],  // 1: ‚Üó
    [-1, 0],  // 2: ‚Üë
    [-1,-1],  // 3: ‚Üñ
    [ 0,-1],  // 4: ‚Üê
    [ 1,-1],  // 5: ‚Üô
    [ 1, 0],  // 6: ‚Üì
    [ 1, 1],  // 7: ‚Üò
  ];
  return map[(dir+8)%8];
}

// get neighbor id in given (dr,dc), or -1 if OOB
function neighborInDir(id, dr, dc){
  const [r,c] = rcOf(id);
  const rr = r + dr, cc = c + dc;
  return inb(rr,cc) ? idx(rr,cc) : -1;
}
  
/* grid size to fit card width (no extra white) */
function setupGridSize(){
  const cols = S.cols, rows = S.rows;
  const gap  = 10;   // must match #grid { gap }
  const pad  = 18;   // must match .card { padding }

  const card = document.querySelector('.card');

  // Inner content box of the card
  const innerW = card.clientWidth  - pad*2;
  const innerH = card.clientHeight - pad*2;

  // Max cell size that fits width and height
  const cellW = Math.floor((innerW - gap*(cols-1)) / cols);
  const cellH = Math.floor((innerH - gap*(rows-1)) / rows);
  const cell  = Math.min(68, cellW, cellH);   // honor your 68px cap

  // Apply
  gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cell}px)`;
  gridEl.style.setProperty('--cell', `${cell}px`);

  // Optional: make the card hug the grid (no extra white)
  const fit = getComputedStyle(card).getPropertyValue('--board-fit').trim();
  if (fit === 'tight'){
    const exactH = rows*cell + gap*(rows-1) + pad*2;
    card.style.height = exactH + 'px';
  } else {
    card.style.height = '100%';   // fill lane; grid will be centered
  }
}

function sizeCells(){
  const isNarrow = gridEl.clientWidth <= 420;
  const gap = isNarrow ? 8 : 10;     // MUST match CSS media queries
  const cols = S.cols;
  const w = gridEl.clientWidth;
  const cell = Math.min(68, Math.floor((w - gap*(cols-1)) / cols));
  gridEl.style.setProperty('--cell', cell + 'px');
  // also keep the grid-template-columns in sync if you prefer fixed pixels:
  gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cell}px)`;
}

function cellPx(){
  const v = getComputedStyle(gridEl).getPropertyValue('--cell');
  return Math.max(20, parseFloat(v)||56);
}  
/* ---------- Build / place ---------- */
function buildEmpty(){ S.grid = Array(S.rows*S.cols).fill(''); }
function allowedDirs(){ return [[0,1],[1,0],[1,1],[1,-1],[-1,1],[-1,-1],[0,-1],[-1,0]]; }
function tryPlaceStraight(w){
  const W=w.split('');
  for(let t=0;t<420;t++){
    const dir = allowedDirs()[R(8)];
    const r0=R(S.rows), c0=R(S.cols);
    const r1=r0+dir[0]*(W.length-1), c1=c0+dir[1]*(W.length-1);
    if (!inb(r1,c1)) continue;
    let ok=true, path=[];
    for(let k=0;k<W.length;k++){
      const r=r0+dir[0]*k, c=c0+dir[1]*k, id=idx(r,c);
      const ch=S.grid[id]; if (ch && ch!==W[k]){ ok=false; break; }
      path.push(id);
    }
    if(!ok) continue;
    for(let k=0;k<W.length;k++) S.grid[path[k]]=W[k];
    S.placed.push({text:w, path});
    return true;
  }
  return false;
}
function fillRandom(){
  const BAG="EEEEEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNRRRRRSSSSTTTTTDLLLLUGGBBCCMMPPFFHHVVWWYKJXQZ";
  for(let i=0;i<S.grid.length;i++) if(!S.grid[i]) S.grid[i]=BAG[R(BAG.length)];
}

/* ---------- Render ---------- */
function renderGrid(){
  gridEl.innerHTML='';
  for(let i=0;i<S.grid.length;i++){
    const d=document.createElement('div'); d.className='cell'; d.textContent=S.grid[i]; d.dataset.idx=i;
    gridEl.appendChild(d);
  }
  setupGridSize();
}
function renderWords(){
  wordList.innerHTML='';
  WORDS.forEach((w,i)=>{
    const el=document.createElement('span'); el.innerHTML=`<b>${w}</b>`; el.id='word_'+i;
    wordList.appendChild(el);
  });
}
function markWordDone(i){ $('#word_'+i)?.classList.add('done'); }

/* ---------- Bands ---------- */
function segmentStraight(path){
  if (path.length<2) return [];
  const segs=[]; let a=path[0], b=path[1];
  let dr=Math.sign(rcOf(b)[0]-rcOf(a)[0]), dc=Math.sign(rcOf(b)[1]-rcOf(a)[1]);
  let cur=[a,b];
  for(let i=2;i<path.length;i++){
    const p=path[i], [rPrev,cPrev]=rcOf(path[i-1]), [r,c]=rcOf(p);
    const dr2=Math.sign(r-rPrev), dc2=Math.sign(c-cPrev);
    if (dr2===dr&&dc2===dc) cur.push(p); else{ segs.push(cur.slice()); cur=[path[i-1],p]; dr=dr2; dc=dc2; }
  }
  segs.push(cur.slice()); return segs;
}
function cellRect(id){
  const cell = gridEl.children[id], hostRect = previewEl.getBoundingClientRect(), r = cell.getBoundingClientRect();
  return { cx:r.left-hostRect.left+r.width/2, cy:r.top-hostRect.top+r.height/2, w:r.width, h:r.height };
}
function clearBands(){ bandsEl.innerHTML=''; } function clearPreview(){ previewEl.innerHTML=''; }
function drawBandSegment(container,aId,bId,color,preview=false){
  const A=cellRect(aId), B=cellRect(bId), dx=B.cx-A.cx, dy=B.cy-A.cy;
  const len=Math.hypot(dx,dy)+Math.min(A.w,A.h)*0.68, angle=Math.atan2(dy,dx)*180/Math.PI;
  const th = Math.min(A.h, A.w)*0.72;
  const d=document.createElement('div'); d.className='band '+color+(preview?' preview':'');
  d.style.width=`${len}px`; d.style.height=`${th}px`;
  d.style.left=`${(A.cx+B.cx)/2-len/2}px`; d.style.top=`${(A.cy+B.cy)/2-th/2}px`;
  d.style.transform=`rotate(${angle}deg)`; container.appendChild(d);
}
function drawPillForPath(path,color,preview=false){
  for(const seg of segmentStraight(path)) drawBandSegment(preview?previewEl:bandsEl, seg[0], seg[seg.length-1], color, preview);
}

/* ---------- Selection / input ---------- */
function neighbors(id){
  const [r,c]=rcOf(id); const out=[];
  for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]]){
    const rr=r+dr, cc=c+dc; if(inb(rr,cc)) out.push(idx(rr,cc));
  } return out;
}
function updateCellSelection(){ [...gridEl.children].forEach(c=>c.classList.remove('sel')); for(const id of S.selPath) gridEl.children[id].classList.add('sel'); }
function redrawPreview(){ clearPreview(); if (S.selPath.length>1) drawPillForPath(S.selPath,'blue',true); }

function setLiveWord(str){
  const box = document.getElementById('liveWord');
  if (!str){ box.innerHTML=''; return; }
  const old = box.textContent || '';
  if (str.startsWith(old) && str.length===old.length+1){
    const s=document.createElement('span'); s.className='ch'; s.textContent=str.at(-1); box.appendChild(s); return;
  }
  box.innerHTML=''; [...str].forEach((ch,i)=>{ const s=document.createElement('span'); s.className='ch'; s.textContent=ch; s.style.animationDelay=(i*12)+'ms'; box.appendChild(s); });
}
function updateLiveWord(){ setLiveWord(S.selPath.length?lettersOf(S.selPath):''); }

function tryMatchCurrent(sel){
  for(let i=0;i<S.placed.length;i++){
    if (S.foundIdx.has(i)) continue; const p=S.placed[i].path;
    if (p.length!==sel.length) continue;
    const fwd=p.every((v,k)=>v===sel[k]), rev=p.every((v,k)=>v===sel[p.length-1-k]);
    if (fwd||rev) return i;
  } return -1;
}
function claim(i){
  S.foundIdx.add(i); markWordDone(i);
  const color=S.bandColors[i%S.bandColors.length]; drawPillForPath(S.placed[i].path,color);
  praise('Nice!');
  checkWin();
}
function praise(msg,type='good'){ const n=document.createElement('div'); n.className='msg '+type; n.textContent=msg; document.getElementById('msgStack').appendChild(n); setTimeout(()=>n.remove(),1100); }

let activePointer = null;

gridEl.addEventListener('pointerdown', e=>{
  const el = e.target.closest('.cell'); if(!el) return;
  gridEl.setPointerCapture(e.pointerId); activePointer = e.pointerId;

  S.dragging = true;
  S.selPath  = [+el.dataset.idx];
  S.curDir   = [0,0];
  S.segLen   = 0;

  updateCellSelection(); redrawPreview(); updateLiveWord();
  e.preventDefault();
},{passive:false});

gridEl.addEventListener('pointermove', e=>{
  if (!S.dragging || e.pointerId !== activePointer) return;

  const lastId = S.selPath[S.selPath.length-1];
  const lastR  = gridEl.children[lastId].getBoundingClientRect();
  const lastCx = lastR.left + lastR.width/2;
  const lastCy = lastR.top  + lastR.height/2;

  // Build neighbor candidates (8-way)
  const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]];
  const candidates = [];
  for (const [dr,dc] of dirs){
    const [r,c] = rcOf(lastId);
    const rr=r+dr, cc=c+dc;
    if (!inb(rr,cc)) continue;
    const nid = idx(rr,cc);
    // allow backtrack one step but not revisiting old cells
    const prev = S.selPath[S.selPath.length-2];
    if (nid !== prev && S.selPath.includes(nid)) continue;

    const nb = gridEl.children[nid].getBoundingClientRect();
    const nCx = nb.left + nb.width/2;
    const nCy = nb.top  + nb.height/2;
    const dx = e.clientX - nCx;
    const dy = e.clientY - nCy;
    const dist2 = dx*dx + dy*dy;
    candidates.push({ nid, dr, dc, dist2 });
  }
  if (!candidates.length) return;

  // Choose the neighbor whose center is closest to the finger
  candidates.sort((a,b)=> a.dist2 - b.dist2);
  const best = candidates[0];

  // Gate: only advance if you're reasonably close to that neighbor
  const d = Math.sqrt(best.dist2);
  const threshold = cellPx()*0.55; // tweak 0.5‚Äì0.65 to taste
  if (d > threshold) return;

  // Hysteresis: require some straight cells before allowing a turn
  const turning = (S.curDir[0] || S.curDir[1]) && (best.dr!==S.curDir[0] || best.dc!==S.curDir[1]);
  if (turning && S.segLen < S.minTurnLen) return;

  // Handle backtrack
  const prev = S.selPath[S.selPath.length-2];
  if (prev!=null && best.nid===prev){
    S.selPath.pop();
    if (S.segLen>0) S.segLen--;
    if (S.segLen===0) S.curDir=[0,0];
    updateCellSelection(); redrawPreview(); updateLiveWord();
    return;
  }

  // Straight-only mode when snake is off
  if (!S.settings.snake && S.selPath.length>=1){
    if (S.curDir[0]===0 && S.curDir[1]===0){ S.curDir=[best.dr,best.dc]; }
    else if (best.dr!==S.curDir[0] || best.dc!==S.curDir[1]) return;
  }

  // Accept step
  S.selPath.push(best.nid);
  if (S.curDir[0]===best.dr && S.curDir[1]===best.dc) S.segLen++;
  else { S.curDir=[best.dr,best.dc]; S.segLen=1; }

  updateCellSelection(); redrawPreview(); updateLiveWord();
  Snd.haptic(6); Snd.tone(300 + S.selPath.length*60, 0.05);
},{passive:false});
  
function endSelection(){
  if (!S.dragging) return;
  S.dragging = false; activePointer = null;

  // --- FULL UNDO: cancel if only 0‚Äì1 cells selected ---
  if (S.selPath.length <= 1){
    S.selPath.length = 0;
    S.curDir = [0,0];
    S.segLen = 0;
    updateCellSelection();
    clearPreview();
    updateLiveWord();
    return;       // <- nothing happens
  }

  // normal resolution flow below
  const w = lettersOf(S.selPath);
  const matchIdx = tryMatchCurrent(S.selPath);
  if (matchIdx >= 0){
    claim(matchIdx);
  } else {
    // optional: only judge ‚Äúnot a word‚Äù when len >= 3
    if (S.selPath.length >= 3 && DICT.has(w) &&
        !S.placed.some(p => p.text===w || p.text===w.split('').reverse().join(''))){
      S.bonusWords.add(w);
      drawPillForPath(S.selPath,'gold');
      praise('Great find! '+w);
    } else {
      // comment this out if you want silence for any miss
      praise('Not a word','bad');
    }
  }

  S.selPath.length = 0;
  S.curDir = [0,0];
  S.segLen = 0;
  updateCellSelection();
  clearPreview();
  updateLiveWord();
}
  addEventListener('pointerup', endSelection, {passive:true});
addEventListener('pointercancel', ()=>{ S.dragging=false; activePointer=null; S.selPath.length=0; updateCellSelection(); clearPreview(); updateLiveWord(); }, {passive:true});

/* ---------- Hint ---------- */
function hint(){
  const i = S.placed.findIndex((p,ix)=>!S.foundIdx.has(ix));
  if (i<0) return;
  const firstId = S.placed[i].path[0];

  [...gridEl.children].forEach(c=>c.classList.remove('hint'));
  const cell = gridEl.children[firstId];
  cell.classList.add('hint');

  // Auto-remove hint after 1 second
  setTimeout(()=> cell.classList.remove('hint'), 1000);
}

/* ---------- Win ---------- */
function confetti(){
  const host=$('#confetti'); host.innerHTML='';
  const colors=['#FF6B6B','#FFD166','#4ECDC4','#C7F464','#C8B6FF','#9ADAFE','#FFB07C'];
  for(let i=0;i<90;i++){ const d=document.createElement('i');
    d.style.left=(Math.random()*100)+'vw'; d.style.top=(-10-Math.random()*30)+'vh';
    d.style.background=colors[R(colors.length)]; d.style.width=d.style.height=(6+Math.random()*8)+'px';
    d.style.animationDuration=(800+Math.random()*700)+'ms'; host.appendChild(d);
  } setTimeout(()=>host.innerHTML='',1600);
}
function checkWin(){
  if (S.foundIdx.size!==S.placed.length) return;
  Snd.stopAll(); confetti(); praise('Level complete!','mega'); Snd.victory();
  const a=new Audio(ASSETS.audio.victory); let done=false;
  a.onended=()=>{ if(!done){ done=true; nextLevel(); } };
  a.onerror=()=>{ if(!done){ done=true; setTimeout(nextLevel,1200);} };
  a.play().catch(()=>{ if(!done){ done=true; setTimeout(nextLevel,1200);} });
  setTimeout(()=>{ if(!done){ done=true; nextLevel(); } },4000);
}

/* ---------- Level ---------- */
function nextLevel(){ S.level++; lvlEl.textContent=S.level; startGame(true); }

/* ---------- UI ---------- */
$('#btnCfg').onclick = ()=> $('#modal').classList.add('show');
$('.close').onclick  = ()=> $('#modal').classList.remove('show');
$('#optSnake').onchange   = e=> S.settings.snake   = e.target.checked;
$('#optHaptics').onchange = e=> S.settings.haptics = e.target.checked;
$('#optTones').onchange   = e=> S.settings.tones   = e.target.checked;
$('#optHC').onchange      = e=>{ S.settings.highContrast=e.target.checked; document.body.classList.toggle('hc',e.target.checked); };
$('#btnHint').onclick = hint;

$('#btnStart').onclick = async ()=>{
  await Snd.userInit();
  await Snd.playSplash();
  startGame();
};

/* ---------- Start / rebuild ---------- */
function startGame(){
  splash.classList.add('hidden');
  gameWrap.classList.remove('hide');

  document.body.style.backgroundImage = `url(${ASSETS.img.search})`;
  document.body.style.backgroundSize='cover';
  document.body.style.backgroundPosition='center';

  S.grid.length=0; S.placed.length=0; S.foundIdx.clear?.(); S.bonusWords.clear?.();
  buildEmpty(); for(const w of WORDS) tryPlaceStraight(w); fillRandom();
  renderWords(); renderGrid(); sizeCells();       // <‚Äî add this
  clearBands(); clearPreview();
  [...gridEl.children].forEach(c=>c.classList.remove('hint'));

  Snd.stopAll(); Snd.startLoop();
}

addEventListener('resize', sizeCells);
addEventListener('orientationchange', ()=> setTimeout(sizeCells, 80));
</script>
</body>
</html>












