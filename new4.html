<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Word-a-Roo</title>

<!-- Conditional base: works locally and on GitHub Pages -->
<script>
(function () {
  var base = document.createElement('base');
  base.href = (location.hostname.endsWith('github.io')) ? '/word-search-proto/' : './';
  document.head.appendChild(base);
})();
</script>

<style>
/* stop iOS font inflation */
html { -webkit-text-size-adjust:100%; text-size-adjust:100%; }

:root{
  --bg:#0c1015; --fg:#e9eef4;
  --panelW:clamp(320px,92vw,760px);
  --panelPad:14px;
}

/* base */
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
  font:600 16px/1.25 system-ui,-apple-system,Segoe UI,Inter,Roboto,Helvetica,Arial,sans-serif;}
button{font:inherit}
.hide{display:none!important}

/* ---------- header chips ---------- */
header{position:fixed;left:0;right:0;top:0;display:flex;flex-wrap:wrap;gap:.6rem;align-items:center;
  padding:.55rem .7rem;z-index:50;pointer-events:none}
.chip{pointer-events:auto;background:rgba(20,20,22,.72);border:1px solid rgba(255,255,255,.12);
  backdrop-filter: blur(8px); border-radius:14px; padding:.38rem .65rem;display:flex;gap:.45rem;
  align-items:center;font-weight:800; white-space:nowrap}
.chip.muted{opacity:.65}

/* ---------- splash ---------- */
#splash{position:fixed;inset:0;background:#000}
#splash.hidden{display:none}
#splash img.bg{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;opacity:.9}
#btnStart{
  position:absolute; left:max(30px, env(safe-area-inset-left));
  bottom:max(30px, env(safe-area-inset-bottom));
  appearance:none;border:none;border-radius:999px;padding:14px 22px;
  background:#0a7bd1;color:#fff;font-weight:900;letter-spacing:.02em;
  box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 -3px 0 rgba(0,0,0,.25); cursor:pointer
}
#btnStart:active{ transform:translateY(1px) }
@media (prefers-reduced-motion:no-preference){
  @keyframes pulse {0%{transform:scale(1);box-shadow:0 0 0 0 rgba(10,123,209,.45)}
    70%{transform:scale(1.03);box-shadow:0 0 0 14px rgba(10,123,209,0)}100%{transform:scale(1)}}
  #btnStart{ animation:pulse 1.6s ease-in-out infinite }
}

/* ===================== game container (NOT full-screen) ===================== */
/* centers the whole card under the header and gives it a fixed play area */
#gameWrap{
  position:fixed;
  left:50%;
  top:56px;                                /* header height */
  transform:translateX(-50%);
  width:var(--panelW);
  height:calc(100svh - 56px - max(12px, env(safe-area-inset-bottom)));
  display:flex;
  justify-content:center;
  align-items:flex-start;
  z-index:1;
}

/* gradient frame */
#gameCard{
  display:flex;
  flex-direction:column;
  gap:10px;
  width:100%;
  height:auto;
  border-radius:34px;
  background:
    linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02)) padding-box,
    linear-gradient(90deg, #1b2a8f, #a24bff) border-box;
  border:9px solid transparent;
  box-shadow:0 20px 50px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.12);
  overflow:hidden;
  clip-path: inset(0 round 34px);
  -webkit-mask-image: -webkit-radial-gradient(white, black);
}

/* Lightning dim */
.lightning #gameCard { opacity:.92; transition:opacity .4s ease; }

/* ---------- word list (top slab) ---------- */
#wordBar{
  background:#fff; color:#000;
  border:1px solid rgba(0,0,0,.10);
  padding:10px var(--panelPad);
  border-top-left-radius:24px; border-top-right-radius:24px;
  border-bottom-left-radius:8px; border-bottom-right-radius:8px;
  box-shadow:0 1px 0 rgba(0,0,0,.06) inset, 0 6px 16px rgba(0,0,0,.05);
}
#wordList{
  display:grid; grid-template-columns:repeat(3, 1fr);
  gap:8px; text-align:center; white-space:nowrap;
}
#wordList b{ font-weight:900 } #wordList .done{ opacity:.35 }

/* ---------- messages lane (middle) ---------- */
#msgArea{
  position:relative; min-height:72px; display:grid; place-items:center; gap:6px; text-align:center;
  background:linear-gradient(180deg, rgba(130,130,160,.45), rgba(130,130,160,.2));
  border-left:1px solid rgba(0,0,0,.08); border-right:1px solid rgba(0,0,0,.08);
}
#liveWord{
  display:inline-flex; gap:.05em; letter-spacing:.1em;
  font-size:clamp(28px,7vw,48px); color:#fff; text-shadow:0 2px 6px rgba(0,0,0,.5)
}
#liveWord .ch{ display:inline-block; transform-origin:50% 60%; animation:pop .22s cubic-bezier(.2,.8,.2,1) }
@keyframes pop{ 0%{transform:scale(.6);opacity:0} 60%{transform:scale(1.12);opacity:1} 100%{transform:scale(1)} }
#msgStack{ position:absolute; inset:0; display:grid; align-content:center; justify-items:center; gap:6px; pointer-events:none; }
.msg{ background:rgba(0,0,0,.78); color:#fff; border-radius:999px; padding:6px 14px; font-weight:900; animation:riseFade .9s ease forwards }
.msg.good{ background:#0a7bd1 } .msg.bad{ background:#b00020 } .msg.mega{ font-size:clamp(28px,8vw,56px); letter-spacing:.06em; padding:8px 18px }
@keyframes riseFade{ 0%{opacity:0;transform:translateY(8px)} 60%{opacity:1;transform:translateY(0)} 100%{opacity:0;transform:translateY(-6px)} }

/* ---------- board (bottom slab) ---------- */
#board{ display:grid; place-items:center; padding-top:4px; }
.card{
  position:relative; width:100%; height:100%;
  background:#fff; border:1px solid rgba(0,0,0,.12);
  border-radius:34px; display:grid; place-items:center;
  overflow:hidden; clip-path: inset(0 round 34px);
  -webkit-mask-image: -webkit-radial-gradient(white, black);
  box-shadow:0 0 0 1px rgba(0,0,0,.02) inset, 0 10px 24px rgba(0,0,0,.08);
  /* NO padding (you asked for this) */
  padding:0 !important;
}
/* overlays for pills: match grid edges exactly */
#bands, #bandsPreview{ position:absolute; inset:0; pointer-events:none; }
.band{ position:absolute; border-radius:9999px; opacity:.92 }
.band.preview{ background:#cdb8ff; opacity:.55; filter:saturate(1.1) }
.band.pink{background:#F59CB0} .band.purple{background:#C8B6FF} .band.green{background:#A8F5A6}
.band.gold{background:#FFD166} .band.blue{background:#9ADAFE} .band.orange{background:#FFB07C}

/* grid */
#grid{ position:relative; display:grid; gap:4px; user-select:none; touch-action:none; }
.cell{
  display:grid; place-items:center; background:transparent; color:#000; font-weight:900;
  width:var(--cell,56px); height:var(--cell,56px); border-radius:16px;
  font-size:calc(var(--cell,56px) * 0.58);
}
.cell.sel{ outline:3px solid #5fb5ff; outline-offset:2px; background:#f1f6ff }
.cell.hint{ position:relative }
.cell.hint::after{ content:""; position:absolute; inset:-4px; border-radius:18px; border:3px dashed #0a7bd1; animation:pulseHint 1s ease-in-out infinite }
@keyframes pulseHint{ 0%{opacity:.2} 50%{opacity:1} 100%{opacity:.2} }

/* confetti */
#confetti{position:fixed;inset:0;pointer-events:none;overflow:hidden;z-index:80}
#confetti i{position:absolute;width:10px;height:10px;background:#fff;opacity:.9;animation:fall 1200ms linear forwards}
@keyframes fall{to{transform:translateY(110vh) rotate(720deg);opacity:.2}}

/* high-contrast toggle */
.hc .cell{color:#000}
.hc #wordBar{background:#000;color:#fff;border-color:#333}

/* ===== Lava lamp background ===== */
:root{ --lava-bg:#0b0b1a; --lava-a:#ff3bc0; --lava-b:#b66bff; --lava-c:#4ecbff; }
#lava{ position:fixed; inset:0; z-index:0; overflow:hidden;
  background: radial-gradient(120vmax 120vmax at 10% 10%, #120a2a 0, #0a0e1a 40%, var(--lava-bg) 70%);
}
#lava .blob{ position:absolute; width:42vmax; height:42vmax; border-radius:50%; filter:blur(40px); opacity:.70; mix-blend-mode:screen; will-change:transform; animation:drift var(--t,28s) ease-in-out infinite alternate;
  background:
    radial-gradient(55% 55% at 35% 35%, var(--c1, var(--lava-a)) 0 55%, transparent 60%),
    radial-gradient(50% 50% at 70% 65%, var(--c2, var(--lava-b)) 0 55%, transparent 60%);
}
#lava .b1{ --c1:var(--lava-a); --c2:var(--lava-b); --t:32s; --x1:-10vw; --y1:-15vh; --x2:15vw; --y2:25vh; }
#lava .b2{ --c1:var(--lava-b); --c2:var(--lava-a); --t:26s; --x1:60vw; --y1:-20vh; --x2:30vw; --y2:15vh; }
#lava .b3{ --c1:var(--lava-a); --c2:var(--lava-c); --t:34s; --x1:10vw; --y1:70vh; --x2:-10vw; --y2:35vh; }
#lava .b4{ --c1:var(--lava-b); --c2:var(--lava-c); --t:29s; --x1:75vw; --y1:60vh; --x2:55vw; --y2:20vh; }
#lava .b5{ --c1:var(--lava-c); --c2:var(--lava-a); --t:38s; --x1:-20vw; --y1:40vh; --x2:20vw; --y2:-10vh; }
@keyframes drift{
  0%   { transform: translate(var(--x1),var(--y1)) scale(0.9) rotate(0deg); }
  50%  { transform: translate(calc((var(--x1) + var(--x2))/2), calc((var(--y1) + var(--y2))/2)) scale(1.05) rotate(10deg); }
  100% { transform: translate(var(--x2),var(--y2)) scale(0.95) rotate(20deg); }
}
@media (prefers-reduced-motion: reduce){ #lava .blob{ animation:none; opacity:.45; } }

/* ===== StormFX overlay ===== */
#stormFX.storm{
  position:fixed; inset:0; z-index:0;
  background-color:#222;
  background-image:url('https://drive.google.com/uc?export=view&id=0BzFF7FmbJUo5X0NEUXFVd0NBcWc');
  background-size:cover; background-position:center; background-repeat:no-repeat;
  pointer-events:none;
}
#stormFX.hide{ display:none; }
#stormFX.storm::after{
  content:""; position:absolute; inset:0;
  background-color:rgba(0,0,0,0.10);
  animation:thunder-bg 6s infinite;
}
#stormFX canvas{ position:absolute; inset:0; width:100%; height:100%; }
#stormFX #sfx-c3{ z-index:5 } #stormFX #sfx-c2{ z-index:10 } #stormFX #sfx-c1{ z-index:100 }
@keyframes thunder-bg{
  0%,9%{background-color:rgba(34,34,34,.90)}
  10%{background-color:rgba(59,59,59,.30)}
  10.5%{background-color:rgba(34,34,34,.90)}
  80%{background-color:rgba(34,34,34,.90)}
  82%{background-color:rgba(59,59,59,.30)}
  83%{background-color:rgba(34,34,34,.90)}
  83.5%{background-color:rgba(59,59,59,.30)}
  100%{background-color:rgba(34,34,34,.90)}
}
@media (prefers-reduced-motion: reduce){
  #stormFX.storm::after{ animation:none; background-color:rgba(34,34,34,.85) }
}

/* ===== Mode Picker ===== */
.sheet{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.6); z-index:60 }
.sheet.hide{ display:none }
.sheetCard{
  width:min(92vw,480px); background:#16181d; color:#fff; border-radius:18px;
  border:1px solid rgba(255,255,255,.12); padding:18px;
}
.sheetCard .sub{ opacity:.8; margin:.2rem 0 1rem }
.btnRow{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin:10px 0 6px }
.mBtn{ appearance:none; border:none; border-radius:14px; padding:12px 16px; font-weight:900; cursor:pointer;
  background:#232633; color:#fff; }
.mBtn.strong{ background:#0a7bd1 }
.ghostBtn{ width:100%; appearance:none; border:1px solid #444; background:transparent; color:#ddd;
  border-radius:10px; padding:10px 12px; margin-top:8px; }
</style>
</head>
<body>

<!-- Lava background (standard) -->
<div id="lava" aria-hidden="true">
  <div class="blob b1"></div><div class="blob b2"></div><div class="blob b3"></div><div class="blob b4"></div><div class="blob b5"></div>
</div>

<!-- Storm overlay (lightning) -->
<div id="stormFX" aria-hidden="true" class="storm hide">
  <canvas id="sfx-c1"></canvas>
  <canvas id="sfx-c2"></canvas>
  <canvas id="sfx-c3"></canvas>
</div>

<!-- Splash -->
<section id="splash" aria-label="Splash">
  <img class="bg" id="splashImg" alt="Splash" src="assets/img/splash.png">
  <button id="btnStart">▶ Start</button>
</section>

<!-- HUD -->
<header>
  <div id="btnCfg" class="chip">⚙️ Settings</div>
  <div id="btnHint" class="chip">💡 Hint</div>
  <div id="badgeMusic" class="chip muted hide">🔇 Music Off</div>
  <div id="badgeFX" class="chip muted hide">🔕 FX Off</div>
  <div class="chip">Level <span id="lvl">1</span></div>
</header>

<!-- Mode Picker -->
<section id="modePicker" class="sheet hide" aria-label="Choose mode">
  <div class="sheetCard">
    <h3>Choose next round</h3>
    <p class="sub">You can change this anytime.</p>
    <div class="btnRow">
      <button id="chooseStandard" class="mBtn">☀️ Standard</button>
      <button id="chooseLightning" class="mBtn strong">⚡ Lightning</button>
    </div>
    <button id="cancelPicker" class="ghostBtn">Cancel</button>
  </div>
</section>

<!-- GAME -->
<main id="gameWrap" class="hide">
  <div id="gameCard">
    <!-- TOP -->
    <div id="wordBar"><div id="wordList"></div></div>
    <!-- MIDDLE -->
    <section id="msgArea">
      <div id="liveWord"></div>
      <div id="msgStack" aria-live="polite"></div>
    </section>
    <!-- BOTTOM -->
    <div id="board">
      <div class="card">
        <div id="bandsPreview"></div>
        <div id="bands"></div>
        <div id="grid" aria-label="letter grid"></div>
      </div>
    </div>
  </div>
</main>

<!-- Settings -->
<div id="modal" class="hide">
  <div class="panel" style="background:#16181d;color:#fff;border:1px solid rgba(255,255,255,.12);border-radius:18px; padding:16px; width:min(92vw,460px); margin:10vh auto;">
    <h3 style="margin:0 0 8px 0">Settings</h3>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Snake Charmer (curving paths)</label><input type="checkbox" id="optSnake" checked></div>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Allow letter reuse (snake)</label><input type="checkbox" id="optRepeat" checked></div>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Music</label><input type="checkbox" id="optMusic" checked></div>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Audio FX</label><input type="checkbox" id="optFX" checked></div>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Tones on drag</label><input type="checkbox" id="optTones" checked></div>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Haptics</label><input type="checkbox" id="optHaptics" checked></div>
    <div class="row" style="display:flex;align-items:center;justify-content:space-between;padding:10px 6px"><label>Reduced sensory</label><input type="checkbox" id="optHC"></div>
    <button class="close" style="margin-top:10px;width:100%">Close</button>
  </div>
</div>

<div id="confetti"></div>

<script>
/* ===== StormFX: Rain + Lightning (fast) ===== */
const StormFX = (()=>{
  let c1,c2,c3,ctx1,ctx2,ctx3,w,h,rafId=null;
  const CFG = {
    rainThroughCount: 400, rainCount: 400, rainThroughSpeed: 25,
    strikeEveryMs: [1200, 2600],          // calmer defaults (tweak as you like)
    boltStepPerFrame: 4, boltPathLimit: [22, 34],
    boltYRange: [12, 28], boltXRange: [6, 26],
    flashChanceBack: 0.04, alphaFade: [0.01, 0.30], lineWidthBase: 3
  };
  const S = { rainTrough:[], rain:[], lightning:[], nextStrikeAt:0, running:false };
  const rand=(a,b)=>a+Math.random()*(b-a), pick=(a,b)=>Math.floor(rand(a,b));
  function mount(){
    c1=document.getElementById('sfx-c1'); c2=document.getElementById('sfx-c2'); c3=document.getElementById('sfx-c3');
    if (!c1) return;
    ctx1=c1.getContext('2d'); ctx2=c2.getContext('2d'); ctx3=c3.getContext('2d');
    onResize(); buildRain(); scheduleNextStrike(); addEventListener('resize', onResize);
  }
  function onResize(){ w=c1.width=c2.width=c3.width=innerWidth; h=c1.height=c2.height=c3.height=innerHeight; }
  function buildRain(){
    S.rainTrough.length=0; for(let i=0;i<CFG.rainThroughCount;i++) S.rainTrough.push({x:rand(0,w),y:rand(0,h),length:Math.floor(rand(1,830)),opacity:Math.random()*0.2,xs:rand(-2,2),ys:rand(10,20)});
    S.rain.length=0; for(let i=0;i<CFG.rainCount;i++) S.rain.push({x:Math.random()*w,y:Math.random()*h,l:Math.random()*1,xs:-4+Math.random()*4+2,ys:Math.random()*10+10});
  }
  function scheduleNextStrike(){ const [a,b]=CFG.strikeEveryMs; S.nextStrikeAt=performance.now()+pick(a,b); }
  function createLightning(){
    const x=rand(100,w-100), y=rand(0,h/4), n=pick(1,2); // fewer forks
    for(let i=0;i<n;i++) S.lightning.push({x,y,xRange:rand(CFG.boltXRange[0],CFG.boltXRange[1]),yRange:rand(CFG.boltYRange[0],CFG.boltYRange[1]),path:[{x,y}],pathLimit:pick(CFG.boltPathLimit[0],CFG.boltPathLimit[1])});
  }
  const clearRain=()=>{ctx1.clearRect(0,0,w,h); ctx2.clearRect(0,0,w,h);};
  function fadeLightning(){ ctx3.globalCompositeOperation='destination-out'; ctx3.fillStyle=`rgba(0,0,0,${rand(CFG.alphaFade[0],CFG.alphaFade[1])})`; ctx3.fillRect(0,0,w,h); ctx3.globalCompositeOperation='source-over'; }
  function drawRainThrough(){
    const sp=CFG.rainThroughSpeed;
    for(const r of S.rainTrough){
      r.y=(r.y>=h)?(h-r.y-r.length*5):(r.y+sp);
      const g=ctx1.createLinearGradient(0,r.y,0,r.y+r.length); g.addColorStop(0,"rgba(255,255,255,0)"); g.addColorStop(1,`rgba(255,255,255,${r.opacity})`);
      ctx1.fillStyle=g; ctx1.fillRect(r.x,r.y,1,r.length);
    }
  }
  function drawRain(){
    ctx2.beginPath(); ctx2.lineWidth=1; ctx2.lineCap='round';
    for(const r of S.rain){
      r.x+=r.xs; r.y+=r.ys; if(r.x>w||r.y>h){ r.x=Math.random()*w; r.y=-20; }
      ctx2.moveTo(r.x,r.y); ctx2.lineTo(r.x+r.l*r.xs, r.y+r.l*r.ys);
    }
    ctx2.strokeStyle='rgba(174,194,224,0.5)'; ctx2.stroke();
  }
  function drawLightning(){
    for(let i=S.lightning.length-1;i>=0;i--){
      const L=S.lightning[i];
      for(let s=0;s<CFG.boltStepPerFrame;s++){
        const p=L.path[L.path.length-1];
        L.path.push({x:p.x+(rand(0,L.xRange)-L.xRange/2), y:p.y+rand(0,L.yRange)});
        if(L.path.length>L.pathLimit){ S.lightning.splice(i,1); break; }
      }
      ctx3.beginPath(); ctx3.moveTo(L.x,L.y); for(let p=0;p<L.path.length;p++) ctx3.lineTo(L.path[p].x,L.path[p].y);
      let lw=CFG.lineWidthBase; if(pick(0,15)===0) lw=6; if(pick(0,30)===0) lw=8;
      ctx3.lineWidth=lw; ctx3.lineJoin='miter'; ctx3.strokeStyle='rgba(255,255,255,0.10)'; ctx3.stroke();
      if(Math.random()<CFG.flashChanceBack){ ctx3.fillStyle=`rgba(255,255,255,${rand(0.01,0.03)})`; ctx3.fillRect(0,0,w,h); }
    }
  }
  function step(now){
    clearRain(); drawRainThrough(); drawRain(); fadeLightning();
    if(now>=S.nextStrikeAt){ createLightning(); scheduleNextStrike(); document.dispatchEvent(new CustomEvent('stormfx:strike')); }
    drawLightning(); rafId=requestAnimationFrame(step);
  }
  function start(){ if(S.running) return; S.running=true; document.getElementById('stormFX')?.classList.remove('hide'); rafId=requestAnimationFrame(step); }
  function stop(){ S.running=false; cancelAnimationFrame(rafId); ctx1?.clearRect(0,0,w,h); ctx2?.clearRect(0,0,w,h); ctx3?.clearRect(0,0,w,h); document.getElementById('stormFX')?.classList.add('hide'); }
  return { mount, start, stop, CFG };
})();
document.addEventListener('DOMContentLoaded', ()=> StormFX.mount());
</script>

<script>
/* ---------- Assets ---------- */
const ASSETS = {
  img:   { splash:'assets/img/splash.png', search:'assets/img/search.png' },
  audio: {
    splash:'assets/audio/splash.mp3',
    search:'assets/audio/search.mp3',
    victory:'assets/audio/victory.mp3',
    thunder1:'assets/audio/thunder1.mp3',
    thunder2:'assets/audio/thunder2.mp3'
  }
};

/* ---------- Tiny audio helper ---------- */
const Snd = (() => {
  const aSplash = new Audio(ASSETS.audio.splash);
  const aLoop   = new Audio(ASSETS.audio.search);
  const aWin    = new Audio(ASSETS.audio.victory);
  const aTh1    = new Audio(ASSETS.audio.thunder1);
  const aTh2    = new Audio(ASSETS.audio.thunder2);
  aLoop.loop = true; aLoop.volume = .55;
  [aSplash,aLoop,aWin,aTh1,aTh2].forEach(a => { try{ a.preload='auto'; a.crossOrigin='anonymous'; }catch{} });

  let unlocked=false, ctx=null, duckTimer=null, lastThunder=0;

  async function userInit(){
    if (unlocked) return;
    try{
      ctx = new (window.AudioContext||window.webkitAudioContext)();
      await ctx.resume();
      [aSplash,aLoop,aWin,aTh1,aTh2].forEach(a=>a.load());
    }catch{}
    unlocked = true;
  }

  async function playSplash(){ try{ aSplash.currentTime=0; await aSplash.play(); }catch{} }
  async function startLoop(){
    if (!S.settings.music) return;
    try{ aLoop.currentTime=0; await aLoop.play(); }catch{}
  }
  function stopLoop(){ try{ aLoop.pause(); }catch{} }
  function stopAll(){ [aSplash,aLoop,aWin,aTh1,aTh2].forEach(a=>{ try{a.pause()}catch{} }); }

  async function victory(){
    if (!S.settings.fx) return;
    try{ aWin.currentTime=0; await aWin.play(); }catch{}
  }

  // loop duck
  function duck(to=0.25, ms=260){
    clearTimeout(duckTimer);
    const from = aLoop.volume;
    const steps = 13, dt = ms/steps;
    let i=0;
    const tick = ()=>{ i++; aLoop.volume = from + (to-from)*(i/steps); if (i<steps) duckTimer=setTimeout(tick, dt); };
    tick();
  }
  function unduck(ms=380){
    clearTimeout(duckTimer);
    const from = aLoop.volume, to = .55;
    const steps = 16, dt = ms/steps;
    let i=0;
    const tick = ()=>{ i++; aLoop.volume = from + (to-from)*(i/steps); if (i<steps) duckTimer=setTimeout(tick, dt); };
    tick();
  }

  async function thunder(prob=0.5, minGapMs=2500){
    if (!S.settings.fx) return;
    const now = performance.now();
    if (Math.random() > prob) return;
    if (now - lastThunder < minGapMs) return;
    lastThunder = now;
    const a = (Math.random()<0.5 ? aTh1 : aTh2);
    try{
      duck();
      a.currentTime=0; try{ a.pause(); }catch{};
      await a.play();
      let cleared=false; const done=()=>{ if(!cleared){ cleared=true; unduck(); } };
      a.onended=done; setTimeout(done, 2200);
    }catch{ unduck(); }
  }

  function tone(freq=440, dur=0.06){
    if (!S.settings.fx || !S.settings.tones || !ctx) return;
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.connect(g).connect(ctx.destination); o.type='sine'; o.frequency.value=freq;
    const t=ctx.currentTime; g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(0.2,t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.start(t); o.stop(t+dur+0.02);
  }

  function haptic(ms=8){
    if (!S.settings.fx || !S.settings.haptics) return;
    if (navigator.vibrate) navigator.vibrate(ms);
  }

  return { userInit, playSplash, startLoop, stopLoop, stopAll, victory, thunder, tone, haptic };
})();

/* ---------- Data ---------- */
const WORDS = ['BIRD','BUG','CLOUD','DRAGON','KITE','EMIT'];
const WORD_INDEX = new Map(WORDS.map((w, i) => [w, i]));
const DICT = new Set(['BIRD','BUG','CLOUD','DRAGON','KITE','EMIT','TIME','TIDE','TREE','STONE','RING','ROAD','RAIN','WIND','FIRE','WATER','EARTH','AIR','SUN','STAR','MOON']);

/* ---------- State ---------- */
const S = {
  roundMode:'standard',
  level:1, rows:7, cols:6, grid:[], placed:[], foundIdx:new Set(), bonusWords:new Set(),
  dragging:false, selPath:[],
  settings:{ snake:true, allowRepeat:true, haptics:true, tones:true, highContrast:false, music:true, fx:true },
  bandColors:['pink','purple','green','gold','blue','orange']
};
S.curDir=[0,0]; S.segLen=0; S.minTurnLen=1;

/* ---------- DOM ---------- */
const $ = s => document.querySelector(s);
const splash = $('#splash'), gridEl = $('#grid'), bandsEl = $('#bands'), previewEl = $('#bandsPreview');
const wordList = $('#wordList'), lvlEl = $('#lvl'), gameWrap = $('#gameWrap');
const modePicker = $('#modePicker'); const chooseStandard = $('#chooseStandard'); const chooseLightning = $('#chooseLightning'); const cancelPicker = $('#cancelPicker');
const badgeMusic = $('#badgeMusic'); const badgeFX = $('#badgeFX');

/* ---------- Helpers ---------- */
const R = n => Math.floor(Math.random()*n);
const idx=(r,c)=> r*S.cols+c, inb=(r,c)=> r>=0&&c>=0&&r<S.rows&&c<S.cols;
const rcOf=id=> [(id/S.cols)|0, id%S.cols];
function lettersOf(path){ return path.map(id=>S.grid[id]).join(''); }

function sizeCells(){
  const gap = 4;                       // sync with CSS
  const cols = S.cols;
  const w = gridEl.clientWidth || gridEl.offsetWidth || 320;
  const cell = Math.min(68, Math.floor((w - gap*(cols-1)) / cols));
  gridEl.style.setProperty('--cell', cell + 'px');
  gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cell}px)`;
}

/* ---------- Build / place ---------- */
function buildEmpty(){ S.grid = Array(S.rows*S.cols).fill(''); }
function allowedDirs(){ return [[0,1],[1,0],[1,1],[1,-1],[-1,1],[-1,-1],[0,-1],[-1,0]]; }
function tryPlaceStraight(w){
  const W=w.split('');
  for(let t=0;t<420;t++){
    const dir = allowedDirs()[R(8)];
    const r0=R(S.rows), c0=R(S.cols);
    const r1=r0+dir[0]*(W.length-1), c1=c0+dir[1]*(W.length-1);
    if (!inb(r1,c1)) continue;
    let ok=true, path=[];
    for(let k=0;k<W.length;k++){
      const r=r0+dir[0]*k, c=c0+dir[1]*k, id=idx(r,c);
      const ch=S.grid[id]; if (ch && ch!==W[k]){ ok=false; break; }
      path.push(id);
    }
    if(!ok) continue;
    for(let k=0;k<W.length;k++) S.grid[path[k]]=W[k];
    S.placed.push({text:w, path});
    return true;
  }
  return false;
}
function fillRandom(){
  const BAG="EEEEEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNRRRRRSSSSTTTTTDLLLLUGGBBCCMMPPFFHHVVWWYKJXQZ";
  for(let i=0;i<S.grid.length;i++) if(!S.grid[i]) S.grid[i]=BAG[R(BAG.length)];
}

/* ---------- Render ---------- */
function renderGrid(){
  gridEl.innerHTML='';
  for(let i=0;i<S.grid.length;i++){
    const d=document.createElement('div'); d.className='cell'; d.textContent=S.grid[i]; d.dataset.idx=i;
    gridEl.appendChild(d);
  }
  sizeCells();
}
function renderWords(){
  wordList.innerHTML='';
  WORDS.forEach((w,i)=>{ const el=document.createElement('span'); el.innerHTML=`<b>${w}</b>`; el.id='word_'+i; wordList.appendChild(el); });
}
function markWordDone(i){ $('#word_'+i)?.classList.add('done'); }

/* ---------- Bands ---------- */
function segmentStraight(path){
  if (path.length<2) return [];
  const segs=[]; let a=path[0], b=path[1];
  let dr=Math.sign(rcOf(b)[0]-rcOf(a)[0]), dc=Math.sign(rcOf(b)[1]-rcOf(a)[1]);
  let cur=[a,b];
  for(let i=2;i<path.length;i++){
    const p=path[i], [rPrev,cPrev]=rcOf(path[i-1]), [r,c]=rcOf(p);
    const dr2=Math.sign(r-rPrev), dc2=Math.sign(c-cPrev);
    if (dr2===dr&&dc2===dc) cur.push(p); else{ segs.push(cur.slice()); cur=[path[i-1],p]; dr=dr2; dc=dc2; }
  }
  segs.push(cur.slice()); return segs;
}
function cellRect(id){
  const cell = gridEl.children[id], hostRect = previewEl.getBoundingClientRect(), r = cell.getBoundingClientRect();
  return { cx:r.left-hostRect.left+r.width/2, cy:r.top-hostRect.top+r.height/2, w:r.width, h:r.height };
}
function clearBands(){ bandsEl.innerHTML=''; } function clearPreview(){ previewEl.innerHTML=''; }
function drawBandSegment(container,aId,bId,color,preview=false){
  const A=cellRect(aId), B=cellRect(bId), dx=B.cx-A.cx, dy=B.cy-A.cy;
  const len=Math.hypot(dx,dy)+Math.min(A.w,A.h)*0.68, angle=Math.atan2(dy,dx)*180/Math.PI;
  const th = Math.min(A.h, A.w)*0.72;
  const d=document.createElement('div'); d.className='band '+color+(preview?' preview':'');
  d.style.width=`${len}px`; d.style.height=`${th}px`;
  d.style.left=`${(A.cx+B.cx)/2-len/2}px`; d.style.top=`${(A.cy+B.cy)/2-th/2}px`;
  d.style.transform=`rotate(${angle}deg)`; container.appendChild(d);
}
function drawPillForPath(path,color,preview=false){
  for(const seg of segmentStraight(path)) drawBandSegment(preview?previewEl:bandsEl, seg[0], seg[seg.length-1], color, preview);
}

/* ---------- Selection / input ---------- */
function neighbors(id){
  const [r,c]=rcOf(id); const out=[];
  for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]]){
    const rr=r+dr, cc=c+dc; if(inb(rr,cc)) out.push(idx(rr,cc));
  } return out;
}
function updateCellSelection(){ [...gridEl.children].forEach(c=>c.classList.remove('sel')); for(const id of S.selPath) gridEl.children[id].classList.add('sel'); }
function redrawPreview(){ clearPreview(); if (S.selPath.length>1) drawPillForPath(S.selPath,'blue',true); }

function setLiveWord(str){
  const box = document.getElementById('liveWord');
  if (!str){ box.innerHTML=''; return; }
  const old = box.textContent || '';
  if (str.startsWith(old) && str.length===old.length+1){
    const s=document.createElement('span'); s.className='ch'; s.textContent=str.at(-1); box.appendChild(s); return;
  }
  box.innerHTML=''; [...str].forEach((ch,i)=>{ const s=document.createElement('span'); s.className='ch'; s.textContent=ch; s.style.animationDelay=(i*12)+'ms'; box.appendChild(s); });
}
function updateLiveWord(){ setLiveWord(S.selPath.length?lettersOf(S.selPath):''); }

/* Snake-aware match */
function tryMatchCurrent(sel){
  if (S.settings.snake){
    const w  = lettersOf(sel);
    const wr = w.split('').reverse().join('');
    let i = WORD_INDEX.get(w);
    if (i != null && !S.foundIdx.has(i)) return { type:'word', index:i, drawPath: sel.slice() };
    i = WORD_INDEX.get(wr);
    if (i != null && !S.foundIdx.has(i)) return { type:'word', index:i, drawPath: sel.slice().reverse() };
    return null;
  }
  // straight mode: match placed paths
  for (let i=0;i<S.placed.length;i++){
    const wordIdx = WORD_INDEX.get(S.placed[i].text);
    if (S.foundIdx.has(wordIdx)) continue;
    const p=S.placed[i].path;
    if (p.length!==sel.length) continue;
    const fwd=p.every((v,k)=>v===sel[k]);
    const rev=p.every((v,k)=>v===sel[p.length-1-k]);
    if (fwd||rev) return { type:'placed', index:i, drawPath:p.slice() };
  }
  return null;
}

/* Claim a found word */
function claim(match){
  const i = match.index;
  let wordIdx = i;
  if (match.type === 'placed'){ const word = S.placed[i].text; wordIdx = WORD_INDEX.get(word); }
  if (wordIdx == null) return;
  S.foundIdx.add(wordIdx);
  markWordDone(wordIdx);
  const color=S.bandColors[wordIdx % S.bandColors.length];
  drawPillForPath(match.drawPath || (S.placed[i] && S.placed[i].path) || [], color);
  praise('Nice!');
  checkWin();
}

let activePointer=null;

/* pointerdown */
gridEl.addEventListener('pointerdown', e=>{
  const el=e.target.closest('.cell'); if(!el) return;
  gridEl.setPointerCapture(e.pointerId); activePointer=e.pointerId;
  S.dragging=true; S.selPath=[+el.dataset.idx];
  S.curDir=[0,0]; S.segLen=0;
  updateCellSelection(); redrawPreview(); updateLiveWord();
  e.preventDefault();
},{passive:false});

/* pointermove */
gridEl.addEventListener('pointermove', e=>{
  if(!S.dragging||e.pointerId!==activePointer) return;
  const el=document.elementFromPoint(e.clientX,e.clientY)?.closest('.cell'); if(!el) return;
  const id=+el.dataset.idx;
  const last=S.selPath[S.selPath.length-1]; if (id===last) return;

  // backtrack
  const prev=S.selPath[S.selPath.length-2];
  if (prev!=null && id===prev){ S.selPath.pop(); if (S.segLen>0) S.segLen--; if (S.segLen===0) S.curDir=[0,0];
    updateCellSelection(); redrawPreview(); updateLiveWord(); return; }

  if (!neighbors(last).includes(id)) return;

  // Reuse policy
  if (!S.settings.snake || !S.settings.allowRepeat){
    if (S.selPath.includes(id)) return;
  } else {
    // optional hard cap to avoid wild spirals
    const LONGEST = Math.max(...WORDS.map(w=>w.length));
    if (S.selPath.length > LONGEST + 6) return;
  }

  // Straight-only when snake off
  if (!S.settings.snake && S.selPath.length>=1){
    const [lr,lc]=rcOf(last), [r,c]=rcOf(id);
    const dr=Math.sign(r-lr), dc=Math.sign(c-lc);
    if (S.curDir[0]===0 && S.curDir[1]===0) S.curDir=[dr,dc];
    else if (dr!==S.curDir[0] || dc!==S.curDir[1]) return;
  }

  // Hysteresis: require some straightness before turning (only matters snake on)
  if (S.settings.snake && S.minTurnLen>1 && S.selPath.length>=2){
    const [lr,lc]=rcOf(last), [r,c]=rcOf(id);
    const dr=Math.sign(r-lr), dc=Math.sign(c-lc);
    const turning = (S.curDir[0] || S.curDir[1]) && (dr!==S.curDir[0] || dc!==S.curDir[1]);
    if (turning && S.segLen < S.minTurnLen) return;
  }

  // accept
  S.selPath.push(id);
  const [lr,lc]=rcOf(last), [r,c]=rcOf(id);
  const dr=Math.sign(r-lr), dc=Math.sign(c-lc);
  if (S.curDir[0]===dr && S.curDir[1]===dc) S.segLen++; else { S.curDir=[dr,dc]; S.segLen=1; }

  updateCellSelection(); redrawPreview(); updateLiveWord();
  Snd.haptic(6); Snd.tone(300 + S.selPath.length*60, 0.05);
},{passive:false});

/* end selection */
function endSelection(){
  if(!S.dragging) return; S.dragging=false; activePointer=null;

  if (S.selPath.length <= 1){
    S.selPath.length=0; S.curDir=[0,0]; S.segLen=0;
    updateCellSelection(); clearPreview(); updateLiveWord(); return;
  }

  const match = tryMatchCurrent(S.selPath);
  if (match){ claim(match); }
  else{
    const w = lettersOf(S.selPath);
    const isTarget = WORD_INDEX.has(w) || WORD_INDEX.has(w.split('').reverse().join(''));
    if (!isTarget && S.selPath.length>=3 && DICT.has(w)){
      S.bonusWords.add(w); drawPillForPath(S.selPath,'gold'); praise('Great find! '+w);
    } else { praise('Not a word','bad'); }
  }

  S.selPath.length=0; S.curDir=[0,0]; S.segLen=0;
  updateCellSelection(); clearPreview(); updateLiveWord();
}
addEventListener('pointerup', endSelection, {passive:true});
addEventListener('pointercancel', ()=>{ S.dragging=false; activePointer=null; S.selPath.length=0; updateCellSelection(); clearPreview(); updateLiveWord(); }, {passive:true});

/* ---------- Hint ---------- */
function hint(){
  // find first unfound WORD index (by list order)
  const nextIdx = WORDS.findIndex((w,i)=>!S.foundIdx.has(i));
  if (nextIdx<0) return;
  // choose first cell of any placed instance of that word (simple)
  const placed = S.placed.find(p=>p.text===WORDS[nextIdx]);
  if (!placed) return;
  const firstId = placed.path[0];
  [...gridEl.children].forEach(c=>c.classList.remove('hint'));
  const cell = gridEl.children[firstId]; cell.classList.add('hint');
  setTimeout(()=> cell.classList.remove('hint'), 1000);
}

/* ---------- Win ---------- */
function confetti(){
  const host=$('#confetti'); host.innerHTML='';
  const colors=['#FF6B6B','#FFD166','#4ECDC4','#C7F464','#C8B6FF','#9ADAFE','#FFB07C'];
  for(let i=0;i<90;i++){ const d=document.createElement('i');
    d.style.left=(Math.random()*100)+'vw'; d.style.top=(-10-Math.random()*30)+'vh';
    d.style.background=colors[R(colors.length)]; d.style.width=d.style.height=(6+Math.random()*8)+'px';
    d.style.animationDuration=(800+Math.random()*700)+'ms'; host.appendChild(d);
  } setTimeout(()=>host.innerHTML='',1600);
}
function checkWin(){
  if (S.foundIdx.size!==WORDS.length) return;
  Snd.stopAll(); confetti(); praise('Level complete!','mega'); Snd.victory();
  setTimeout(()=> nextLevel(), 1400);
}

/* ---------- Level ---------- */
function nextLevel(){ S.level++; lvlEl.textContent=S.level; modePicker.classList.remove('hide'); }

/* ---------- UI ---------- */
$('#btnCfg').onclick = ()=> $('#modal').classList.remove('hide');
$('.close').onclick  = ()=> $('#modal').classList.add('hide');
$('#optSnake').onchange   = e=> S.settings.snake   = e.target.checked;
$('#optRepeat').onchange  = e=> S.settings.allowRepeat = e.target.checked;
$('#optHaptics').onchange = e=> S.settings.haptics = e.target.checked;
$('#optTones').onchange   = e=> S.settings.tones   = e.target.checked;
$('#optHC').onchange      = e=>{ S.settings.highContrast=e.target.checked; document.body.classList.toggle('hc',e.target.checked); };
$('#optMusic').onchange   = e=>{ S.settings.music = e.target.checked; updateBadges(); if(!e.target.checked) Snd.stopLoop(); else Snd.startLoop(); };
$('#optFX').onchange      = e=>{ S.settings.fx    = e.target.checked; updateBadges(); };

$('#btnHint').onclick = hint;

function updateBadges(){
  badgeMusic.classList.toggle('hide', !!S.settings.music);
  badgeFX.classList.toggle('hide', !!S.settings.fx);
}

/* Start button → mode picker */
$('#btnStart').onclick = async ()=>{
  await Snd.userInit();
  await Snd.playSplash();
  modePicker.classList.remove('hide');
};

/* Mode selection */
function beginMode(mode){
  S.roundMode = mode;
  modePicker.classList.add('hide');
  startGame();
}
chooseStandard.onclick  = ()=> beginMode('standard');
chooseLightning.onclick = ()=> beginMode('lightning');
cancelPicker.onclick    = ()=> modePicker.classList.add('hide');

/* Lightning strike hook */
function onStormStrike(){
  if (!S.settings.highContrast){
    Snd.thunder(0.45, 2500);   // softer frequency: 45% chance, ≥2.5s apart
    if (navigator.vibrate) navigator.vibrate(60);
  }
}

/* ---------- Start / rebuild ---------- */
function startGame(){
  splash.classList.add('hidden');
  gameWrap.classList.remove('hide');

  if (S.roundMode === 'lightning'){
    document.body.classList.add('lightning');
    document.getElementById('lava').style.display = 'none';
    StormFX.start();
    document.addEventListener('stormfx:strike', onStormStrike);
  } else {
    document.body.classList.remove('lightning');
    document.getElementById('lava').style.display = 'block';
    StormFX.stop();
    document.removeEventListener('stormfx:strike', onStormStrike);
  }

  // build
  S.grid.length=0; S.placed.length=0; S.foundIdx.clear?.(); S.bonusWords.clear?.();
  buildEmpty(); for(const w of WORDS) tryPlaceStraight(w); fillRandom();
  renderWords(); renderGrid(); clearBands(); clearPreview();
  [...gridEl.children].forEach(c=>c.classList.remove('hint'));

  updateBadges();
  Snd.stopAll(); Snd.startLoop();
}

addEventListener('resize', sizeCells);
addEventListener('orientationchange', ()=> setTimeout(sizeCells, 80));

/* splash image */
document.getElementById('lava').style.display = 'none';
document.getElementById('splashImg').src = ASSETS.img.splash;

/* simple praise */
function praise(msg,type='good'){
  const n=document.createElement('div');
  n.className='msg '+type; n.textContent=msg;
  document.getElementById('msgStack').appendChild(n);
  setTimeout(()=>n.remove(),1100);
}
</script>
</body>
</html>
